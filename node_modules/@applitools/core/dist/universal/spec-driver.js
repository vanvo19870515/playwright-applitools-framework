"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSpec = void 0;
const utils = __importStar(require("@applitools/utils"));
function makeSpec({ socket, spec, }) {
    const commands = {
        isDriver(driver) {
            return utils.types.has(driver, 'applitools-ref-id');
        },
        isContext(context) {
            return utils.types.has(context, 'applitools-ref-id');
        },
        isElement(element) {
            return utils.types.has(element, ['applitools-ref-id', 'type']) && element.type === 'element';
        },
        isSelector(selector) {
            return ((utils.types.has(selector, ['applitools-ref-id', 'type']) && selector.type === 'selector') ||
                utils.types.isString(selector) ||
                (utils.types.isPlainObject(selector) &&
                    utils.types.has(selector, 'selector') &&
                    (utils.types.isString(selector.selector) || utils.types.has(selector, 'applitools-ref-id'))));
        },
        async isEqualElements(context, element1, element2) {
            return socket.request('Driver.isEqualElements', { context, element1, element2 });
        },
        isStaleElementError(error) {
            return error === null || error === void 0 ? void 0 : error.isStaleElementError;
        },
        extractContext(driver) {
            return driver.context;
        },
        extractSelector(element) {
            return element.selector;
        },
        async executeScript(context, script, arg) {
            return socket.request('Driver.executeScript', { context, script: script.toString(), arg });
        },
        async findElement(context, selector, parent) {
            return socket.request('Driver.findElement', { context, selector, parent });
        },
        async findElements(context, selector, parent) {
            return socket.request('Driver.findElements', { context, selector, parent });
        },
        async waitForSelector(context, selector, parent, options) {
            return socket.request('Driver.waitForSelector', { context, selector, parent, options });
        },
        async getElementText(context, element) {
            return socket.request('Driver.getElementText', { context, element });
        },
        async setElementText(context, element, text) {
            return socket.request('Driver.setElementText', { context, element, text });
        },
        async getElementRegion(context, element) {
            return socket.request('Driver.getElementRegion', { context, element });
        },
        async getElementAttribute(context, element, attr) {
            return socket.request('Driver.getElementAttribute', { context, element, attr });
        },
        async hover(context, element) {
            return socket.request('Driver.hover', { context, element });
        },
        async click(context, element) {
            return socket.request('Driver.click', { context, element });
        },
        async mainContext(context) {
            return socket.request('Driver.mainContext', { context });
        },
        async parentContext(context) {
            return socket.request('Driver.parentContext', { context });
        },
        async childContext(context, element) {
            return socket.request('Driver.childContext', { context, element });
        },
        async getCapabilities(driver) {
            return socket.request('Driver.getCapabilities', { driver });
        },
        async getDriverInfo(driver) {
            return socket.request('Driver.getDriverInfo', { driver });
        },
        async getWindowSize(driver) {
            return socket.request('Driver.getWindowSize', { driver });
        },
        async setWindowSize(driver, size) {
            return socket.request('Driver.setWindowSize', { driver, size });
        },
        async getViewportSize(driver) {
            return socket.request('Driver.getViewportSize', { driver });
        },
        async setViewportSize(driver, size) {
            return socket.request('Driver.setViewportSize', { driver, size });
        },
        async getSystemBars(driver) {
            return socket.request('Driver.getSystemBars', { driver });
        },
        async getOrientation(driver) {
            return socket.request('Driver.getOrientation', { driver });
        },
        async setOrientation(driver, orientation) {
            return socket.request('Driver.setOrientation', { driver, orientation });
        },
        async getCookies(driver, context) {
            return socket.request('Driver.getCookies', { driver, context });
        },
        async getTitle(driver) {
            return socket.request('Driver.getTitle', { driver });
        },
        async getUrl(driver) {
            return socket.request('Driver.getUrl', { driver });
        },
        async takeScreenshot(driver) {
            return socket.request('Driver.takeScreenshot', { driver });
        },
        async performAction(driver, steps) {
            return socket.request('Driver.performAction', { driver, steps });
        },
        async visit(driver, url) {
            return socket.request('Driver.visit', { driver, url });
        },
        async getCurrentWorld(driver) {
            return socket.request('Driver.getCurrentWorld', { driver });
        },
        async getWorlds(driver) {
            return socket.request('Driver.getWorlds', { driver });
        },
        async switchWorld(driver, name) {
            return socket.request('Driver.switchWorld', { driver, name });
        },
        async reload(driver) {
            return socket.request('Driver.reload', { driver });
        },
        async isUserFunction(ref) {
            return utils.types.has(ref, 'applitools-ref-id');
        },
        async executeUserFunction(userFunction) {
            return socket.request('Driver.executeUserFunction', userFunction);
        },
        async executeBrowserCommands(driver, commands) {
            return socket.request('Driver.executeBrowserCommands', { driver, commands });
        },
    };
    // add default commands to spec (if not already there) such as `isUserFunction`
    spec = addDefaultCommands(spec);
    return spec.reduce((spec, name) => {
        return Object.assign(spec, { [name]: commands[name] });
    }, {});
}
exports.makeSpec = makeSpec;
// returns a new clone of the spec commands array with additional commands universal can support even if the spec doesn't
function addDefaultCommands(spec) {
    const defaultCommands = [
        {
            command: 'isUserFunction',
            dependsOn: ['executeUserFunction'],
        },
    ];
    const commands = spec.slice();
    defaultCommands.forEach(({ command, dependsOn }) => {
        if (!commands.includes(command) && dependsOn.every(dep => commands.includes(dep))) {
            commands.push(command);
        }
    });
    return commands;
}
