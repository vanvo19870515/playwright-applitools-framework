"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runOfflineSnapshots = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("../core");
const get_ufg_client_1 = require("../ufg/get-ufg-client");
const to_base_check_settings_1 = require("../automation/utils/to-base-check-settings");
const logger_1 = require("@applitools/logger");
const chalk_1 = __importDefault(require("chalk"));
const utils = __importStar(require("@applitools/utils"));
const merge_configs_1 = require("./merge-configs");
const format_results_1 = require("../utils/format-results");
const throat_1 = __importDefault(require("throat"));
const os_1 = __importDefault(require("os"));
const extract_git_info_1 = require("../utils/extract-git-info");
const open_eyes_1 = require("../open-eyes");
const throttledReadFile = (0, throat_1.default)(Number(process.env.APPLITOOLS_FILE_READING_CONCURRENCY) || 1000, fs_1.default.promises.readFile);
function getConsoleLogLimit() {
    var _a;
    return (_a = utils.general.getEnvValue('OFFLINE_LOG_LIMIT', 'number')) !== null && _a !== void 0 ? _a : 20;
}
function version() {
    try {
        return JSON.parse(fs_1.default.readFileSync(require.resolve('../../package.json'), 'utf-8')).version;
    }
    catch (e) {
        return 'unknown';
    }
}
async function runOfflineSnapshots(options) {
    var _a;
    const limitConsoleLogs = getConsoleLogLimit();
    const throttledRender = (0, throat_1.default)(Number(process.env.APPLITOOLS_RENDER_CONCURRENCY) || 1000, render);
    if (!options.offlineLocationPath)
        throw new Error('offlineLocationPath is required');
    const offlineLocationPath = path_1.default.resolve(options.offlineLocationPath);
    const startTime = Date.now();
    const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : (0, logger_1.makeLogger)({ format: { label: 'offline-exec' } });
    const eyesServerSettings = { ...options.config.open, ...options };
    const core = (0, core_1.makeCore)({ agentId: `js/core-offline/${version()}`, logger });
    const account = await core.getAccountInfo({ settings: eyesServerSettings });
    const ufgClient = await (0, get_ufg_client_1.makeGetUFGClient)({ logger })({
        settings: { ...account.eyesServer, ...account.ufgServer },
    });
    const testFolders = (await fs_1.default.promises.readdir(offlineLocationPath))
        .filter(filename => filename.startsWith('test-'))
        .sort();
    void logStartupInfo();
    if (testFolders.length === 1) {
        logger.console.log(`Running single test from folder ${offlineLocationPath}`);
    }
    else if (testFolders.length === 0) {
        logger.console.log('No test artifacts were found at', offlineLocationPath);
    }
    else {
        logger.console.log(`Running ${testFolders.length} tests from folder ${offlineLocationPath}`);
    }
    if (testFolders.length === 0) {
        throw new Error(`Unable to find offline executions in ${offlineLocationPath}`);
    }
    const allTestResults = await runTests(testFolders);
    const { isSuccess, outputStr } = processResults({
        testResults: allTestResults,
        totalTime: Date.now() - startTime,
        jsonFilePath: options.jsonFilePath,
        saveNewTests: options.config.close.updateBaselineIfNew,
    });
    if (!isSuccess.onErrors && options.failOnError) {
        throw new Error(outputStr);
    }
    else if (!isSuccess.onDiffs && options.failOnDiff) {
        throw new Error(outputStr);
    }
    else {
        logger.console.log(outputStr);
    }
    return allTestResults;
    async function runTests(testFolders) {
        logger.log('running tests', testFolders);
        const messages = [];
        const testPromises = testFolders.map(async (testFolder) => {
            const testLogger = logger.extend({ tags: [testFolder] });
            const testPath = path_1.default.join(offlineLocationPath, testFolder);
            const fileOpenSettings = await fs_1.default.promises
                .readFile(path_1.default.join(testPath, 'settings.json'), 'utf-8')
                .then(JSON.parse);
            const openSettings = (0, merge_configs_1.mergeConfigs)(fileOpenSettings, options.config.open);
            messages.push(`Running test: ${openSettings.testName} (${formatEnvironment(openSettings.environment)})`);
            return { testPath, openSettings, testLogger };
        });
        const preparedTests = await Promise.all(testPromises);
        if (messages.length > limitConsoleLogs) {
            const slice = messages.slice(0, limitConsoleLogs);
            logger.console.log(slice.join('\n') + `\n... ${messages.length - limitConsoleLogs} more tests`);
        }
        else {
            logger.console.log(messages.join('\n'));
        }
        const testConcurrency = utils.general.getEnvValue('TEST_CONCURRENCY', 'number');
        const runTestThrottled = testConcurrency ? (0, throat_1.default)(testConcurrency, runTest) : runTest;
        const results = await Promise.all(preparedTests.map(async ({ testPath, openSettings, testLogger }) => {
            return runTestThrottled(testPath, openSettings, testLogger);
        }));
        const batchIds = [...new Set(results.map(t => t.batchId))];
        const allTestResults = results.map(t => t.results);
        logger.log('done running all tests', allTestResults);
        const keepBatchOpen = utils.general.getEnvValue('DONT_CLOSE_BATCHES', 'boolean') || options.config.open.keepBatchOpen;
        if (!keepBatchOpen) {
            await core.closeBatch({ settings: batchIds.map(batchId => ({ batchId, ...account.eyesServer })) });
            logger.log('done closing batches');
        }
        return allTestResults;
    }
    async function runTest(testPath, openSettings, logger) {
        const environment = await ufgClient.getActualEnvironment({
            settings: { environment: openSettings.environment.requested },
        });
        const closeSettings = await getCloseSettings(testPath);
        let resultsGetter;
        if (closeSettings) {
            const targets = await getCheckTargets(testPath, logger);
            const uploadResourcePromise = uploadResources(targets, logger).then(() => logger.log('uploaded resources for test', testPath));
            if (targets.length === 1) {
                logger.log('only one check found for test', testPath);
                try {
                    await uploadResourcePromise;
                    const target = targets[0];
                    resultsGetter = await runOpenCheckAndClose({
                        ...target,
                        settings: {
                            ...(0, merge_configs_1.mergeConfigs)(target.settings, (0, merge_configs_1.mergeConfigs)(openSettings, closeSettings)),
                            ...account.eyesServer,
                            environment: {
                                ...openSettings.environment,
                                ...target.settings.environment,
                            },
                        },
                    }, logger, environment);
                    logger.log('finished running checks for test', testPath);
                }
                catch (err) {
                    logger.log('error running checks for test', testPath, err);
                    resultsGetter = await makeAbortedTest(openSettings, environment, logger, err);
                }
            }
            else {
                const eyes = await openEyes(openSettings, environment, logger);
                logger.log('opened eyes for test', testPath);
                const lastTarget = targets.pop();
                try {
                    await uploadResourcePromise;
                    await Promise.all(targets.map((target, index) => runCheck(eyes, target, index, logger)));
                    if (lastTarget) {
                        lastTarget.settings = (0, merge_configs_1.mergeConfigs)(lastTarget.settings, closeSettings);
                        await runCheckAndClose(eyes, lastTarget, targets.length - 1, logger);
                        logger.log('finished running checks for test', testPath);
                    }
                    else {
                        logger.log('no checks found for test', testPath);
                        // on empty test, `checkAndClose` will not be called so we need to call `close` instead
                        await eyes.close({ settings: closeSettings });
                    }
                }
                catch (err) {
                    logger.log('error running checks for test', testPath, err);
                    await eyes.abort({
                        logger,
                        settings: {
                            reason: err,
                        },
                    });
                }
                resultsGetter = eyes;
            }
        }
        else {
            logger.log('no close settings found for test - aborting test', testPath);
            resultsGetter = await makeAbortedTest(openSettings, environment, logger);
        }
        logger.log('done running test', testPath);
        return { batchId: openSettings.batch.id, results: (await resultsGetter.getResults({ logger }))[0] };
    }
    async function getCloseSettings(testPath) {
        const closeSettingsPath = path_1.default.resolve(testPath, 'close.json');
        if (fs_1.default.existsSync(closeSettingsPath)) {
            const fileCloseSettings = await throttledReadFile(closeSettingsPath, 'utf-8').then(JSON.parse);
            const closeSettings = (0, merge_configs_1.mergeConfigs)(fileCloseSettings, options.config.close);
            return closeSettings;
        }
        return undefined;
    }
    async function getCheckTargets(testPath, logger) {
        const checkFolders = (await fs_1.default.promises.readdir(testPath)).filter(folderpath => folderpath.startsWith('check-'));
        logger.log('check folders', checkFolders);
        const targets = await Promise.all(checkFolders.map(async (checkFolder) => {
            const snapshot = await fs_1.default.promises
                .readFile(path_1.default.resolve(testPath, checkFolder, 'snapshot.json'), 'utf-8')
                .then(JSON.parse);
            snapshot.settings.environment.environmentId = utils.general.guid();
            return snapshot;
        }));
        return targets;
    }
    async function makeAbortedTest(openSettings, environment, logger, reason = 'internal') {
        const eyes = await openEyes(openSettings, environment, logger);
        await eyes.abort({
            settings: {
                reason,
            },
        });
        return eyes;
    }
    async function openEyes(settings, environment, logger) {
        const eyes = await core.base.openEyes({
            settings: {
                latestCommitInfo: await getLatestCommitInfo({ logger, execOptions: { cwd: offlineLocationPath } }),
                ...settings,
                environment: {
                    ...settings.environment,
                    ...environment,
                },
                ...account.eyesServer,
            },
            logger,
        });
        return eyes;
    }
    async function uploadResources(targets, logger) {
        const uploadLogger = logger.extend({ tags: ['upload-resources'] });
        const promises = targets.map(async ({ target }) => {
            const resourcePromises = Object.values(target.resources)
                .filter(isHashedResource)
                .map(async (resource) => {
                return ufgClient.uploadResource({
                    resource: {
                        hash: resource,
                        async getter() {
                            return {
                                id: '',
                                url: '',
                                value: await throttledReadFile(path_1.default.join(offlineLocationPath, 'resources', resource.hash)),
                                contentType: resource.contentType,
                                hash: resource,
                            };
                        },
                    },
                    logger: uploadLogger,
                });
            });
            resourcePromises.push(ufgClient.uploadResource({
                resource: {
                    hash: target.snapshot,
                    async getter() {
                        return {
                            id: '',
                            url: '',
                            value: await throttledReadFile(path_1.default.join(offlineLocationPath, 'resources', target.snapshot.hash)),
                            contentType: target.snapshot.contentType,
                            hash: target.snapshot,
                        };
                    },
                },
                logger: uploadLogger,
            }));
            return Promise.all(resourcePromises);
        });
        await Promise.all(promises);
        function isHashedResource(resource) {
            return 'hash' in resource;
        }
    }
    async function runCheck(eyes, target, index, logger) {
        var _a;
        const checkLogger = logger.extend({ tags: [`check-${index}`] });
        const { mergedCheckSettings, baseTarget } = await throttledRender(target, checkLogger);
        (_a = mergedCheckSettings.stepIndex) !== null && _a !== void 0 ? _a : (mergedCheckSettings.stepIndex = index);
        await eyes.check({
            target: { ...baseTarget, isTransformed: true },
            settings: mergedCheckSettings,
            logger: checkLogger,
        });
        logger.log('check finished', mergedCheckSettings);
        return eyes;
    }
    async function runCheckAndClose(eyes, target, index, logger) {
        var _a;
        const checkLogger = logger.extend({ tags: [`check-${index}`] });
        const { mergedCheckSettings, baseTarget } = await throttledRender(target, checkLogger);
        (_a = mergedCheckSettings.stepIndex) !== null && _a !== void 0 ? _a : (mergedCheckSettings.stepIndex = index);
        await eyes.checkAndClose({
            target: { ...baseTarget, isTransformed: true },
            settings: mergedCheckSettings,
            logger: checkLogger,
        });
        logger.log('checkAndClose finished', mergedCheckSettings);
        return eyes;
    }
    async function runOpenCheckAndClose(target, logger, actualEnvironment) {
        const checkLogger = logger.extend({ tags: ['open-check-and-close'] });
        const { mergedCheckSettings, baseTarget } = await throttledRender(target, checkLogger);
        const settings = (0, merge_configs_1.mergeConfigs)(target.settings, mergedCheckSettings);
        return core.base.openCheckAndCloseEyes({
            target: { ...baseTarget, isTransformed: true },
            settings: {
                ...settings,
                latestCommitInfo: await getLatestCommitInfo({ logger, execOptions: { cwd: offlineLocationPath } }),
                environment: {
                    ...settings.environment,
                    ...actualEnvironment,
                },
            },
            logger: checkLogger,
            heartbeat: {
                processId: '',
                startPeriodicHeartbeatMessaging(settings) {
                    logger.log('heartbeat is not used (offline)', settings);
                },
            },
        });
    }
    async function render(target, logger) {
        var _a;
        const { elementReferences: selectors, getBaseCheckSettings } = (0, to_base_check_settings_1.toBaseCheckSettings)({
            settings: target.settings,
        });
        const { renderId, selectorRegions, ...baseTarget } = await ufgClient.render({
            target: target.target,
            settings: {
                ...target.settings,
                region: (_a = selectors.target) !== null && _a !== void 0 ? _a : target.settings.region,
                scrollRootElement: selectors.scrolling,
                selectorsToCalculate: selectors.calculate,
                includeFullPageSize: Boolean(target.settings.pageId),
                environment: target.settings.environment,
                uploadUrl: account.uploadUrl,
                stitchingServiceUrl: account.stitchingServiceUrl,
            },
            logger,
        });
        const baseSettings = getBaseCheckSettings({
            calculatedRegions: selectors.calculate.map((_, index) => {
                var _a;
                return ({
                    regions: (_a = selectorRegions === null || selectorRegions === void 0 ? void 0 : selectorRegions[index]) !== null && _a !== void 0 ? _a : [],
                });
            }),
        });
        baseSettings.renderId = renderId;
        // baseSettings.stepIndex = index
        baseTarget.source = target.target.source; // TODO verify
        // baseTarget.name = snapshot.title // TODO figure out
        const mergedCheckSettings = (0, merge_configs_1.mergeConfigs)(baseSettings, options.config.check);
        return { mergedCheckSettings, baseTarget };
    }
    async function logStartupInfo() {
        await core.logEvent({
            logger,
            settings: {
                ...account.eyesServer,
                ...account.ufgServer,
                level: 'Notice',
                event: {
                    type: 'offlineExecutionStart',
                    timestamp: new Date().toISOString(),
                    offlineLocationPath,
                    testCount: testFolders.length,
                    ufgServerUrl: account.ufgServer.ufgServerUrl,
                    CI: process.env.CI,
                    config: options.config,
                    driver: {
                        platform: os_1.default.platform(),
                        version: os_1.default.release(),
                        arch: os_1.default.arch(),
                        cpu: {
                            count: os_1.default.cpus().length,
                            avgSpeed: os_1.default.cpus().reduce((acc, cpu) => acc + cpu.speed, 0) / os_1.default.cpus().length,
                            model: os_1.default.cpus()[0].model,
                        },
                        memory: {
                            total: os_1.default.totalmem(),
                            free: os_1.default.freemem(),
                        },
                        nodeVersion: process.version,
                        versions: await Promise.all(['eyes', 'core', 'core-base', 'ufg-client']
                            .map(async (name) => ({
                            name,
                            version: JSON.parse(await throttledReadFile(require.resolve(`@applitools/${name}/package.json`), {
                                encoding: 'utf-8',
                            })).version,
                        }))
                            .map(promise => promise.catch(e => `failed to get version: ${e}`))),
                    },
                },
            },
        });
    }
}
exports.runOfflineSnapshots = runOfflineSnapshots;
function uniq(arr) {
    return [...new Set(arr)];
}
function processResults({ testResults, totalTime, saveNewTests = true, jsonFilePath, }) {
    let outputStr = '\n';
    const pluralize = utils.general.pluralize;
    const testResultsWithErrors = testResults.filter(r => r && r.reason);
    const unresolved = testResults.filter(r => r.isDifferent && !r.isAborted);
    const passedOrNew = testResults.filter(r => r.status === 'Passed' || (r.isNew && !r.isAborted));
    const aborted = testResults.filter(r => r.isAborted);
    const newTests = testResults.filter(r => r.isNew && !r.isAborted);
    const failedTests = testResults.filter(r => !r.reason && !r.isNew && !r.isAborted && !r.isDifferent && r.status === 'Failed');
    const newTestsSize = newTests.length;
    const warnForUnsavedNewTests = !!(!saveNewTests && newTestsSize);
    const errMessagesToExclude = ['detected differences', 'Please approve the new baseline', 'is failed! See details at'];
    const errors = testResultsWithErrors
        .filter(r => !errMessagesToExclude.some(msg => { var _a, _b; return (_b = (_a = r.reason) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes(msg); }))
        .map(r => ({
        error: r.reason,
        title: r.name,
    }));
    const hasResults = unresolved.length || passedOrNew.length || aborted.length;
    const seeDetailsStr = hasResults && `See details at ${(passedOrNew[0] || unresolved[0] || aborted[0]).appUrls.batch}`;
    if (hasResults) {
        outputStr += `${seeDetailsStr}\n\n`;
    }
    outputStr += '[EYES: TEST RESULTS]:\n\n';
    if (passedOrNew.length > 0) {
        outputStr += testResultsOutput(passedOrNew, warnForUnsavedNewTests, 'Passed');
    }
    if (failedTests.length > 0) {
        outputStr += testResultsOutput(failedTests, warnForUnsavedNewTests, 'Failed');
    }
    if (unresolved.length > 0) {
        outputStr += testResultsOutput(unresolved, warnForUnsavedNewTests, 'Unresolved');
    }
    if (aborted.length > 0) {
        outputStr += testResultsOutput(aborted, warnForUnsavedNewTests, 'Aborted');
    }
    if (errors.length) {
        const sortedErrors = errors.sort((a, b) => a.title.localeCompare(b.title));
        outputStr += uniq(sortedErrors.map(({ title, error }) => `${title} - ${chalk_1.default.red('Failed')}. ${error.message || error.toString()}`)).join('\n');
        outputStr += '\n';
    }
    if (!errors.length && !hasResults) {
        outputStr += 'Test is finished but no results returned.\n';
    }
    const unresolvedOrFailed = unresolved.concat(failedTests);
    if (errors.length && !unresolvedOrFailed.length) {
        outputStr += chalk_1.default.red(`\nA total of ${errors.length} test${pluralize(errors.length)} failed for unexpected error${pluralize(errors.length)}.`);
    }
    else if (unresolvedOrFailed.length && !errors.length) {
        outputStr += chalk_1.default.keyword(failedTests.length ? 'red' : 'orange')(`\nA total of ${unresolvedOrFailed.length} difference${pluralize(unresolvedOrFailed.length, [
            's were',
            ' was',
        ])} found.`);
    }
    else if (unresolvedOrFailed.length || errors.length) {
        outputStr += chalk_1.default.red(`\nA total of ${unresolvedOrFailed.length} difference${pluralize(unresolvedOrFailed.length, [
            's were',
            ' was',
        ])} found and ${errors.length} test${pluralize(errors.length)} failed for ${pluralize(errors.length, [
            '',
            'an ',
        ])}unexpected error${pluralize(errors.length)}.`);
    }
    else if (warnForUnsavedNewTests) {
        const countText = newTestsSize > 1 ? `are ${newTestsSize} new tests` : `is a new test: '${newTests[0].name}'`;
        outputStr += chalk_1.default.red(`\n'saveNewTests' was set to false and there ${countText}. Please approve ${pluralize(newTestsSize, [
            'their',
            'its',
        ])} baseline${pluralize(newTestsSize)} in Eyes dashboard.\n`);
    }
    else if (passedOrNew.length) {
        outputStr += chalk_1.default.green(`\nNo differences were found!`);
    }
    if (jsonFilePath) {
        outputStr += '\n\nWriting test results to ' + jsonFilePath + '\n';
        fs_1.default.writeFileSync(jsonFilePath, (0, format_results_1.toJsonOutput)(testResults));
    }
    if (hasResults) {
        outputStr += `\n${seeDetailsStr}\nTotal time: ${Math.round(totalTime / 1000)} seconds\n`;
    }
    // if (Number(testConcurrency) === 5) {
    //   outputStr += `\n${concurrencyMsg}\n`
    // }
    const isSuccess = { onErrors: true, onDiffs: true };
    isSuccess.onErrors = !errors.length;
    isSuccess.onDiffs = !!(!warnForUnsavedNewTests && passedOrNew.length && !unresolvedOrFailed.length);
    return {
        outputStr,
        isSuccess,
    };
}
function testResultsOutput(results, warnForUnsavedNewTests, tag) {
    const limitConsoleLogs = getConsoleLogLimit();
    const truncated = [];
    let limitCount = 0;
    const sortedTestResults = results.sort((a, b) => a.name.localeCompare(b.name));
    sortedTestResults.forEach(result => {
        const testTitle = `${result.name} [${result.hostApp}] [${result.hostDisplaySize.width}x${result.hostDisplaySize.height}] - `;
        if (result.isAborted) {
            const str = `${testTitle}${chalk_1.default.keyword('red')(`Aborted`)}\n`;
            truncated.push(str);
        }
        else if (result.isNew) {
            const newResColor = warnForUnsavedNewTests ? 'orange' : 'blue';
            const str = `${testTitle}${chalk_1.default.keyword(newResColor)('New')}\n`;
            truncated.push(str);
        }
        else if (result.status === 'Passed') {
            const str = `${testTitle}${chalk_1.default.green('Passed')}\n`;
            truncated.push(str);
        }
        else if (result.status === 'Failed') {
            const str = `${testTitle}${chalk_1.default.keyword('red')('Failed')}\n`;
            truncated.push(str);
        }
        else {
            const str = `${testTitle}${chalk_1.default.keyword('orange')(`Unresolved`)}\n`;
            truncated.push(str);
        }
        if (limitCount < limitConsoleLogs)
            limitCount++;
    });
    let outputStr = truncated.slice(0, limitConsoleLogs).join('');
    outputStr += results.length - limitCount > 0 ? `... ${results.length - limitCount} more ${tag} tests` : '';
    outputStr += '\n';
    return outputStr;
}
function formatEnvironment(environment) {
    const env = environment.requested;
    if (isChromeEmulation(env)) {
        return `${env.chromeEmulationInfo.deviceName}${env.chromeEmulationInfo.screenOrientation ? ` [${env.chromeEmulationInfo.screenOrientation}]` : ''}`;
    }
    else if (isIOSDevice(env)) {
        return `${env.iosDeviceInfo.deviceName}${env.iosDeviceInfo.screenOrientation ? ` [${env.iosDeviceInfo.screenOrientation}]` : ''}`;
    }
    else if (isAndroidDevice(env)) {
        return `${env.androidDeviceInfo.deviceName}${env.androidDeviceInfo.screenOrientation ? ` [${env.androidDeviceInfo.screenOrientation}]` : ''}`;
    }
    else {
        return `${env.name} [${env.width}x${env.height}]`;
    }
    function isChromeEmulation(env) {
        return env.chromeEmulationInfo;
    }
    function isIOSDevice(env) {
        return env.iosDeviceInfo;
    }
    function isAndroidDevice(env) {
        return env.androidDeviceInfo;
    }
}
async function getLatestCommitInfo({ logger, execOptions = { cwd: process.cwd() }, }) {
    var _a;
    const result = (_a = (0, open_eyes_1.getLatestCommitInfoFromEnvVars)(logger)) !== null && _a !== void 0 ? _a : (await (0, extract_git_info_1.extractLatestCommitInfo)({ execOptions, logger }));
    if (result && !(0, extract_git_info_1.isISODate)(result.timestamp)) {
        logger.warn(`latestCommitInfo.timestamp is an invalid ISO date string: ${result.timestamp} - ignoring`);
    }
    else
        return result;
}
