"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.captureImagesFunc = void 0;
function captureImagesFunc() {
    async function isNonBlackImage(dataUrl) {
        const img = new Image();
        img.src = dataUrl;
        await new Promise((resolve, reject) => {
            img.onload = () => resolve();
            img.onerror = () => reject();
        });
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        if (!ctx)
            return false;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        for (let i = 0; i < imageData.length; i += 4) {
            if (imageData[i] !== 0 || imageData[i + 1] !== 0 || imageData[i + 2] !== 0) {
                return true;
            }
        }
        return false;
    }
    function processWebGLCanvases(win) {
        Array.from(win.document.getElementsByTagName('canvas')).forEach((canvas) => {
            const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
            if (!gl)
                return;
            const attrs = gl.getContextAttributes();
            if (!attrs)
                return;
            const { preserveDrawingBuffer } = attrs;
            if (!preserveDrawingBuffer && canvas.width > 0 && canvas.height > 0) {
                const dataUrl = canvas.toDataURL('image/png');
                if ((canvas.dataset.dataUrl || '') === dataUrl)
                    return;
                isNonBlackImage(dataUrl).then(result => {
                    if (result) {
                        canvas.dataset.dataUrl = dataUrl;
                    }
                });
            }
        });
    }
    function patchRequestAnimationFrame(win) {
        var _a;
        if (win.__rafPatched) {
            return;
        }
        const HTMLCanvasElementCtor = win.HTMLCanvasElement ||
            (win.constructor && win.constructor.HTMLCanvasElement) ||
            (win.document && ((_a = win.document.defaultView) === null || _a === void 0 ? void 0 : _a.HTMLCanvasElement));
        const origGetContext = (HTMLCanvasElementCtor && HTMLCanvasElementCtor.prototype.getContext);
        if (!origGetContext) {
            return;
        }
        const originalRAF = win.requestAnimationFrame;
        win.requestAnimationFrame = function (callback) {
            const rafId = originalRAF.call(this, (time) => {
                callback.call(win, time);
                processWebGLCanvases(win);
            });
            return rafId;
        };
        win.__rafPatched = true;
    }
    function takeCanvasScreenshots(win = window) {
        if (win.__rafPatched) {
            return;
        }
        try {
            patchRequestAnimationFrame(win);
        }
        catch (e) { }
    }
    Object.assign(window, { takeCanvasScreenshots });
    takeCanvasScreenshots();
}
exports.captureImagesFunc = captureImagesFunc;
