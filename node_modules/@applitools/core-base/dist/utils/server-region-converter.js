"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverRegionConverter = void 0;
const utils = __importStar(require("@applitools/utils"));
function serverRegionConverter(settings) {
    return {
        ignore: toRegions(settings.ignoreRegions),
        layout: toRegions(settings.layoutRegions),
        strict: toRegions(settings.strictRegions),
        content: toRegions(settings.contentRegions),
        floating: toRegions(settings.floatingRegions),
        accessibility: toAccessibilityRegions(settings.accessibilityRegions),
        dynamic: toDynamicRegions(settings.dynamicRegions),
    };
}
exports.serverRegionConverter = serverRegionConverter;
function toRegions(regions) {
    return regions === null || regions === void 0 ? void 0 : regions.map(region => toServerRegion(region)).sort(regionSort).reduce(deduplicatedRegionIds(), []);
}
function toAccessibilityRegions(regions) {
    return regions === null || regions === void 0 ? void 0 : regions.map(region => {
        const serverRegion = toServerRegion(region);
        if (utils.types.has(region, 'type')) {
            serverRegion.type = region.type;
        }
        return serverRegion;
    }).sort(regionSort).reduce(deduplicatedRegionIds(), []);
}
function toDynamicRegions(regions) {
    return regions === null || regions === void 0 ? void 0 : regions.map(region => {
        const serverRegion = toServerRegion(region);
        if (utils.types.has(region, 'type')) {
            serverRegion.dynamicSettings = {
                ignorePatterns: utils.types.isArray(region.type) ? region.type : [region.type],
            };
        }
        return serverRegion;
    }).sort(regionSort).reduce(deduplicatedRegionIds(), []);
}
function toServerRegion(region) {
    var _a;
    const options = {};
    if (utils.types.has(region, 'region')) {
        options.regionId = region.regionId;
        if (utils.types.has(region, 'offset')) {
            const offset = region.offset;
            options.maxUpOffset = offset.top;
            options.maxDownOffset = offset.bottom;
            options.maxLeftOffset = offset.left;
            options.maxRightOffset = offset.right;
        }
        region = utils.geometry.padding(region.region, (_a = region.padding) !== null && _a !== void 0 ? _a : 0);
    }
    region = utils.geometry.round(region);
    return { left: region.x, top: region.y, width: region.width, height: region.height, ...options };
}
function regionSort(region1, region2) {
    if (region1.top !== region2.top)
        return region1.top > region2.top ? 1 : -1;
    else if (region1.left !== region2.left)
        return region1.left > region2.left ? 1 : -1;
    else
        return 0;
}
function deduplicatedRegionIds() {
    const stats = {};
    return (regions, region, index) => {
        if (!region.regionId)
            return regions.concat(region);
        if (!stats[region.regionId]) {
            stats[region.regionId] = { firstIndex: index, count: 1 };
            return regions.concat(region);
        }
        const stat = stats[region.regionId];
        if (stat.count === 1) {
            regions[stat.firstIndex] = { ...regions[stat.firstIndex], regionId: `${region.regionId} (${stat.count})` };
        }
        stat.count += 1;
        return regions.concat({ ...region, regionId: `${region.regionId} (${stat.count})` });
    };
}
