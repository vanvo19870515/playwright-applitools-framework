"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectTypes = exports.expect = void 0;
const test_1 = require("@playwright/test");
const index_1 = require("./index");
const getEyes_1 = require("./getEyes");
exports.expect = test_1.expect.extend({
    async toHaveScreenshot(pageOrLocator, nameOrOptions = {}, optOptions = {}) {
        var _a, _b, _c, _d, _e, _f;
        const testInfo = index_1.test.info();
        if (!testInfo) {
            throw new Error(`toHaveScreenshot() must be called during the test`);
        }
        if ((_a = testInfo._projectInternal) === null || _a === void 0 ? void 0 : _a.ignoreSnapshots)
            return { pass: !this.isNot, message: () => '', name: 'toHaveScreenshot', expected: nameOrOptions };
        if (this.isNot) {
            // eslint-disable-next-line no-console
            console.warn("Applitools visual tests don't support negating visual assertions - the `.not` will be ignored");
            // uncomment if we'll decide to fallback to the Playwright default not.toHaveScreenshot mechanism
            // if (typeof nameOrOptions === 'string' || Array.isArray(nameOrOptions)) {
            //   await baseExpect(pageOrLocator).not.toHaveScreenshot(nameOrOptions, optOptions)
            // } else {
            //   await baseExpect(pageOrLocator).not.toHaveScreenshot({...nameOrOptions, ...optOptions})
            // }
        }
        expectTypes(pageOrLocator, ['Page', 'Locator'], 'toHaveScreenshot');
        const [page, locator] = pageOrLocator.constructor.name === 'Page'
            ? [pageOrLocator, undefined]
            : [pageOrLocator.page(), pageOrLocator];
        const options = {
            ...optOptions,
            ...(typeof nameOrOptions === 'object' ? nameOrOptions : {}),
        };
        const unsupportedOptions = [
            {
                flag: options.animations === 'disabled',
                message: 'animations option is not supported by Applitools',
            },
            {
                flag: options.caret === 'initial',
                message: '`caret: initial` is not supported by Applitools',
            },
            {
                flag: locator && options.clip,
                message: 'using both locator and clip options at the same time is not supported by Applitools',
            },
            {
                flag: options.omitBackground,
                message: 'the omitBackground option is not supported by Applitools',
            },
            {
                flag: options.scale === 'css',
                message: 'the CSS scale option is not supported by Applitools',
            },
            {
                flag: options.style,
                message: 'style option is not supported by Applitools',
            },
            {
                flag: options.stylePath,
                message: 'stylePath option is not supported by Applitools',
            },
        ];
        for (const { flag, message } of unsupportedOptions) {
            if (flag) {
                // eslint-disable-next-line no-console
                console.warn(`Warning - ${message}. This option will be ignored.`);
            }
        }
        const redundantOptions = [
            {
                flag: options.maskColor,
                message: 'maskColor option is not used by Applitools',
            },
            {
                flag: options.quality,
                message: 'quality option is not used by Applitools',
            },
            {
                flag: options.maxDiffPixelRatio,
                message: 'maxDiffPixelRatio option is not used by Applitools',
            },
            {
                flag: options.maxDiffPixels,
                message: 'maxDiffPixels option is not used by Applitools',
            },
            {
                flag: options.threshold,
                message: 'threshold option is not used by Applitools',
            },
        ];
        for (const { flag, message } of redundantOptions) {
            if (flag) {
                // eslint-disable-next-line no-console
                console.warn(`${message}, because Applitools utilizes smarter comparison algorithms that mimic the humn eyesight, and therefore do not require using that option. Feel free to remove that hard-coded configuration as it's not used and no longer needed.`);
            }
        }
        const configuration = (_b = page.__eyesConfig) !== null && _b !== void 0 ? _b : {};
        configuration.properties = [
            ...((_c = configuration.properties) !== null && _c !== void 0 ? _c : []),
            {
                name: 'playwright: expect.toHaveScreenshot options',
                value: JSON.stringify(options),
            },
            {
                name: 'playwright: syntax used',
                value: 'toHaveScreenshot',
            },
        ];
        if (this.isNot) {
            configuration.properties.push({
                name: 'negated',
                value: 'true',
            });
        }
        await (await (0, getEyes_1.getEyes)({
            testInfo,
            eyesConfig: (_d = page.__eyesConfig) !== null && _d !== void 0 ? _d : {},
            eyesRunner: (_e = page.__eyesRunner) !== null && _e !== void 0 ? _e : {},
            page,
        })).check({
            name: typeof nameOrOptions === 'string'
                ? nameOrOptions
                : Array.isArray(nameOrOptions)
                    ? nameOrOptions.join('-')
                    : typeof (nameOrOptions === null || nameOrOptions === void 0 ? void 0 : nameOrOptions.name) === 'string'
                        ? nameOrOptions.name
                        : undefined,
            region: locator !== null && locator !== void 0 ? locator : options.clip,
            fully: (_f = options.fullPage) !== null && _f !== void 0 ? _f : configuration.fully,
            ignoreRegions: options.mask,
        });
        return {
            pass: true,
            message: () => 'screenshot taken, comparison is in progress. The results will be reported after the test ends (soft assertion).',
        };
    },
});
function expectTypes(receiver, types, matcherName) {
    if (typeof receiver !== 'object' || !types.includes(receiver.constructor.name)) {
        const commaSeparated = types.slice();
        const lastType = commaSeparated.pop();
        const typesString = commaSeparated.length ? commaSeparated.join(', ') + ' or ' + lastType : lastType;
        throw new Error(`${matcherName} can be only used with ${typesString} object${types.length > 1 ? 's' : ''}`);
    }
}
exports.expectTypes = expectTypes;
