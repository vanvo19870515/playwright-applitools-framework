import type { LogLevel } from './log-level';
import type { formatter } from './formatter';
export interface Logger extends Printer {
    readonly isLogger: true;
    readonly options: Readonly<LoggerOptions>;
    readonly console: Printer;
    extend(loggerOrOptions?: Logger | (Omit<FormatOptions, 'level'> & {
        level?: LogLevelName | number;
        console?: boolean | Handler;
        maskLog?: boolean;
    }), options?: Omit<FormatOptions, 'level'> & {
        level?: LogLevelName | number;
        console?: boolean | Handler;
        maskLog?: boolean;
    }): Logger;
    wrap?(anotherLogger: Logger): Logger;
    colorize(string: string, options?: {
        color?: Style | Style[];
    }): string;
    open(): void;
    close(): void;
    mask(value: string): void;
}
export type LoggerOptions = Omit<Partial<PrinterOptions>, 'handler' | 'level'> & {
    logger?: Logger;
    handler?: ConsoleHandler | FileHandler | RollingFileHandler | DebugHandler | Handler;
    console?: boolean | Handler;
    level?: LogLevelName | number;
    maskLog?: boolean;
};
export interface Printer {
    debug(...messages: any[]): void;
    log(...messages: any[]): void;
    info(...messages: any[]): void;
    warn(...messages: any[]): void;
    error(...messages: any[]): void;
    fatal(...messages: any[]): void;
    /** @deprecated */
    verbose(...messages: any[]): void;
}
export type PrinterOptions = {
    handler: Handler;
    level: number;
    format?: Omit<FormatOptions, 'level'> & {
        formatter?: typeof formatter;
    };
    masks?: Set<string>;
    maskLog?: boolean;
};
export type ConsoleHandler = {
    type: 'console';
};
export type DebugHandler = {
    type: 'debug';
    label?: string;
};
export type FileHandler = {
    type: 'file';
    filename?: string;
    append?: boolean;
};
export type RollingFileHandler = {
    type: 'rolling file';
    dirname?: string;
    name?: string;
    maxFileLength?: number;
    maxFileNumber?: number;
};
export interface Handler {
    log(message: any): void;
    warn?(message: any): void;
    error?(message: any): void;
    fatal?(message: any): void;
    open?(): void;
    close?(): void;
}
export type LogLevelName = keyof typeof LogLevel;
type Color = 'black' | 'red' | 'green' | 'yellow' | 'blue' | 'magenta' | 'cyan' | 'white' | 'gray' | 'grey' | 'blackBright' | 'redBright' | 'greenBright' | 'yellowBright' | 'blueBright' | 'magentaBright' | 'cyanBright' | 'whiteBright';
type BGColor = `bg${Capitalize<Color>}`;
export type Style = Color | BGColor;
export type ColoringOptions = {
    timestamp?: Style | Style[];
    level?: {
        [key in LogLevelName]?: Style | Style[];
    };
    label?: Style | Style[];
    tags?: Style | Style[];
    message?: Style | Style[];
};
export type FormatOptions = {
    prelude?: boolean;
    label?: string;
    timestamp?: Date | boolean;
    level?: LogLevelName;
    tags?: string[] | string[][];
    colors?: ColoringOptions | boolean;
    maskLog?: boolean;
    masks?: Set<string>;
};
export interface SpyLogger extends Logger {
    readonly isSpyLogger: true;
    readonly calls: ReadonlyArray<LogCall>;
    waitForNextCall(timeout?: number): Promise<void>;
    waitForLength(length: number, timeout?: number): Promise<void>;
    waitForLog(message: string, options?: {
        level?: LogLevelName;
        timeout?: number;
    }): Promise<void>;
}
export interface LogCall {
    readonly level: LogLevelName;
    readonly message: any;
}
export {};
