"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeStaleElementsFromDomSnapshotsSettings = exports.filterStaleElements = exports.isStale = void 0;
async function isStale({ context, element, }) {
    try {
        await context.execute('return arguments[0]', element);
    }
    catch {
        return true;
    }
    return false;
}
exports.isStale = isStale;
async function filterStaleElements({ context, elementReferences, }) {
    if (!elementReferences)
        return [];
    const validElements = [];
    for (const element of elementReferences) {
        if (!(await isStale({ context, element }))) {
            validElements.push(element);
        }
    }
    return validElements;
}
exports.filterStaleElements = filterStaleElements;
async function removeStaleElementsFromDomSnapshotsSettings({ context, settings, targetElement, }) {
    // if one of the stale elements is the target element, we can't recover from it
    if (await isStale({ context, element: targetElement })) {
        throw new Error('Target element is stale - please make sure the element is not detached from the DOM tree. Failed to recover from stale element');
    }
    else {
        // remove other stale elements from the array
        settings.elementReferences = await filterStaleElements({
            context,
            elementReferences: settings.elementReferences,
        });
    }
    return settings;
}
exports.removeStaleElementsFromDomSnapshotsSettings = removeStaleElementsFromDomSnapshotsSettings;
