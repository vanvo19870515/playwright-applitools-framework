export declare function getEnvValue<T extends 'boolean' | 'number' | 'string' = 'string'>(name: string, type?: T): T extends 'boolean' ? boolean : T extends 'number' ? number : T extends 'string' ? string : string | undefined;
/**
 * Retrieves the value of an environment variable in a case-insensitive manner.
 *
 * Traversing in order upper case, lower case and mixed case
 *
 * @param {string} key - The name of the environment variable to lookup.
 * @return {string | undefined} The value of the environment variable if found, or undefined if not found.
 */
export declare function getEnvCaseInsensitive(key: string): string | undefined;
export declare function guid(): string;
export declare function shortid(): string;
export declare function jwtDecode(token: string): Record<string, any>;
export declare function sleep(ms: number): Promise<unknown> | undefined;
export declare function toJSON<TObject extends Record<PropertyKey, any>, TKey extends string, TProps extends Readonly<TKey[]>>(object: TObject, props: TProps): {
    [key in TProps[number]]: TObject[key] extends {
        toJSON(): any;
    } ? ReturnType<TObject[key]['toJSON']> : TObject[key];
};
export declare function toJSON<TObject extends Record<PropertyKey, any>, TKey extends string, TProps extends Readonly<Record<TKey, PropertyKey>>>(object: TObject, props: TProps): {
    [key in keyof TProps]: TObject[TProps[key]] extends {
        toJSON(): any;
    } ? ReturnType<TObject[TProps[key]]['toJSON']> : TObject[TProps[key]];
};
export declare function toJSON<TObject extends Record<PropertyKey, any>>(object: TObject): {
    [key in keyof Omit<TObject, symbol>]: TObject[key] extends {
        toJSON(): any;
    } ? ReturnType<TObject[key]['toJSON']> : TObject[key];
};
export declare function toString(object: Record<PropertyKey, any>): string;
export declare function toUnAnchoredUri(url: string): string;
export declare function toUriEncoding(url: string): string;
export declare function removeUndefinedProps<TObject extends Record<string, any>>(object: TObject): TObject;
export declare function absolutizeUrl(url: string, baseUrl: string): string;
export declare function cachify<TFunc extends (...args: any[]) => any>(func: TFunc, getKey?: (args: Parameters<TFunc>) => any): TFunc & {
    getCachedValues(): ReturnType<TFunc>[];
    setCachedValue(key: any, value: ReturnType<TFunc>): void;
    clearCache(): void;
};
export declare function clearCachify(): void;
export declare function batchify<TFunc extends (batch: [TInput, {
    resolve(result?: TResult): void;
    reject(reason?: any): void;
}][]) => Promise<void>, TInput = Parameters<TFunc>[0][number][0], TResult = Parameters<Parameters<TFunc>[0][number][1]['resolve']>[0]>(func: TFunc, { timeout, maxPending }: {
    timeout: number;
    maxPending?: number;
}): (input: Parameters<TFunc>[0][number][0]) => Promise<TResult>;
export declare function wrap<TFunc extends (...args: any[]) => any>(func: TFunc, wrapper: (func: TFunc, ...args: Parameters<TFunc>) => ReturnType<TFunc>): TFunc;
export declare function extend<TTarget extends Record<PropertyKey, any>, TExtension extends Record<PropertyKey, any>>(target: TTarget, extension: TExtension | ((result: any) => TExtension)): TTarget & TExtension;
export declare function pluralize(object: [] | number, config?: [manyCase: string, singleCase: string]): string;
export declare function deepEqual(value1: any, value2: any): boolean;
/**
 * Deduplicates an array based on a custom equality function, applies an asynchronous transformation
 * to the unique values, and maps the results back to the original array structure.
 *
 * @param items - The array of items to process.
 * @param transform - A function that receives unique items and returns transformed results.
 * @param isEqual - A function that determines whether two items are considered equal.
 * @returns A Promise resolving to an array where each item is replaced with its transformed result.
 */
export declare function dedupAndMap<T extends object, R>(items: T[], transform: (arr: T[]) => Promise<R[]>, isEqual: (a: T, b: T) => boolean): Promise<R[]>;
/**
 * Zips two arrays together, yielding pairs of elements from each array.
 * If the arrays are of different lengths, the shorter length is used (it's the user res)
 */
export declare function zip<A, B>(a: A[], b: B[]): Generator<[A, B]>;
