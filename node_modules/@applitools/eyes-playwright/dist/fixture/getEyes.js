"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEyes = void 0;
const test_1 = require("@playwright/test");
const index_1 = require("../index");
const eyesConfiguration_1 = require("./defaults/eyesConfiguration");
const url_1 = require("url");
async function getEyes({ testInfo, eyesConfig, eyesRunner, page, }) {
    var _a, _b, _c, _d, _e;
    if (page.__eyes) {
        return page.__eyes;
    }
    const { configFile } = testInfo.config;
    const playwrightConfigModule = configFile ? await import((0, url_1.pathToFileURL)(configFile).href) : {};
    const playwrightConfig = ((_a = playwrightConfigModule === null || playwrightConfigModule === void 0 ? void 0 : playwrightConfigModule.use) === null || _a === void 0 ? void 0 : _a.eyesConfig) ||
        ((_c = (_b = playwrightConfigModule === null || playwrightConfigModule === void 0 ? void 0 : playwrightConfigModule.default) === null || _b === void 0 ? void 0 : _b.use) === null || _c === void 0 ? void 0 : _c.eyesConfig);
    const projectConfig = testInfo.project.use.eyesConfig;
    const configuration = (0, eyesConfiguration_1.getFinalEyesConfiguration)({
        playwrightConfig,
        projectConfig,
        eyesConfig,
        testInfo,
    });
    // TODO remove this once bug in eyes/core is fixed. The bug is that when passing browsersInfo with classic runner, a test with viewport size 0x0 is created for each browser configuration. It should just be ignored.
    if (eyesRunner.type === 'classic' && configuration.browsersInfo) {
        delete configuration.browsersInfo;
    }
    const eyes = new index_1.Eyes(eyesRunner, {
        // batches are closed automatically after some time, and closing batch from one process might make another process to open a new batch when it's not neccessary.
        // therefore, we decides to set dontCloseBatches to true. If the user wants to see a notification after the batch is closed, we expect them to use our
        // custom playwright reporter, or to sent the notification manually in their CI pipeline
        dontCloseBatches: true,
        ...configuration,
    });
    addLogHandlers(eyes, (_e = (_d = eyesConfig.logConfig) !== null && _d !== void 0 ? _d : projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.logConfig) !== null && _e !== void 0 ? _e : playwrightConfig === null || playwrightConfig === void 0 ? void 0 : playwrightConfig.logConfig, testInfo);
    eyes.open = makeStep('eyes.open', eyes.open.bind(eyes));
    eyes.check = makeStep('eyes.check', eyes.check.bind(eyes));
    eyes.close = makeStep('eyes.close', eyes.close.bind(eyes));
    eyes.closeAsync = makeStep('eyes.closeAsync (without exception)', eyes.closeAsync.bind(eyes));
    await eyes.open(page, configuration.appName, configuration.testName);
    page.__eyes = eyes;
    eyesRunner.isUsed = true;
    return eyes;
}
exports.getEyes = getEyes;
function makeStep(title, f, { box } = { box: true }) {
    return (async (...args) => {
        const stepTitle = typeof args[0] === 'string' ? `${title} - ${args[0]}` : title;
        return test_1.test.step(stepTitle, async () => {
            return await f(...args);
        }, { box });
    });
}
function addLogHandlers(eyes, logsConfig, testInfo) {
    if (typeof logsConfig === 'function') {
        addLogHandlers(eyes, logsConfig(testInfo), testInfo);
    }
    else if (Array.isArray(logsConfig)) {
        logsConfig.forEach(logSetting => addLogHandlers(eyes, logSetting, testInfo));
    }
    else if (logsConfig) {
        eyes.setLogHandler(logsConfig);
    }
}
