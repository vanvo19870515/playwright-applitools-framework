"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Target = exports.TargetAutomation = exports.TargetImage = exports.CheckSettingsAutomationFluent = exports.CheckSettingsImageFluent = exports.CheckSettingsBaseFluent = void 0;
const AccessibilityRegionType_1 = require("../enums/AccessibilityRegionType");
const MatchLevel_1 = require("../enums/MatchLevel");
const utils = __importStar(require("@applitools/utils"));
class CheckSettingsBaseFluent {
    constructor(settings, parent) {
        var _a;
        this._settings = {};
        this.childs = [];
        this._settings = utils.types.instanceOf(settings, CheckSettingsBaseFluent) ? settings.toObject() : settings !== null && settings !== void 0 ? settings : {};
        this.parent = (parent !== null && parent !== void 0 ? parent : settings === null || settings === void 0 ? void 0 : settings.parent);
        if (parent) {
            (_a = parent.childs) !== null && _a !== void 0 ? _a : (parent.childs = []);
            parent.childs.push(this);
        }
        else {
            this._settings = utils.types.instanceOf(settings, CheckSettingsBaseFluent) ? settings.toObject() : settings !== null && settings !== void 0 ? settings : {};
        }
    }
    region(region) {
        this._settings.region = region;
        return this;
    }
    name(name) {
        this._settings.name = name;
        return this;
    }
    withName(name) {
        return this.name(name);
    }
    ignoreRegion(region) {
        if (region) {
            if (!this._settings.ignoreRegions)
                this._settings.ignoreRegions = [];
            this._settings.ignoreRegions.push(region);
        }
        return this;
    }
    ignoreRegions(...regions) {
        regions.forEach(region => this.ignoreRegion(region));
        return this;
    }
    /** @deprecated */
    ignore(region) {
        return this.ignoreRegion(region);
    }
    /** @deprecated */
    ignores(...regions) {
        return this.ignoreRegions(...regions);
    }
    layoutRegion(region) {
        if (region) {
            if (!this._settings.layoutRegions)
                this._settings.layoutRegions = [];
            this._settings.layoutRegions.push(region);
        }
        return this;
    }
    layoutRegions(...regions) {
        regions.forEach(region => this.layoutRegion(region));
        return this;
    }
    strictRegion(region) {
        if (region) {
            if (!this._settings.strictRegions)
                this._settings.strictRegions = [];
            this._settings.strictRegions.push(region);
        }
        return this;
    }
    strictRegions(...regions) {
        regions.forEach(region => this.strictRegion(region));
        return this;
    }
    contentRegion(region) {
        if (region) {
            if (!this._settings.contentRegions)
                this._settings.contentRegions = [];
            this._settings.contentRegions.push(region);
        }
        return this;
    }
    contentRegions(...regions) {
        regions.forEach(region => this.contentRegion(region));
        return this;
    }
    floatingRegion(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset) {
        if (region) {
            let floatingRegion;
            if (utils.types.has(region, 'region')) {
                const { maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset, ...rest } = region;
                floatingRegion = {
                    offset: { top: maxUpOffset, bottom: maxDownOffset, left: maxLeftOffset, right: maxRightOffset },
                    ...rest,
                };
            }
            else {
                floatingRegion = {
                    region,
                    offset: { top: maxUpOffset, bottom: maxDownOffset, left: maxLeftOffset, right: maxRightOffset },
                };
            }
            if (!this._settings.floatingRegions)
                this._settings.floatingRegions = [];
            this._settings.floatingRegions.push(floatingRegion);
        }
        return this;
    }
    floatingRegions(regionOrMaxOffset, ...regions) {
        let maxOffset;
        if (utils.types.isNumber(regionOrMaxOffset)) {
            maxOffset = regionOrMaxOffset;
        }
        else {
            this.floatingRegion(regionOrMaxOffset);
        }
        regions.forEach(region => {
            if (utils.types.has(region, 'region'))
                this.floatingRegion(region);
            else
                this.floatingRegion(region, maxOffset, maxOffset, maxOffset, maxOffset);
        });
        return this;
    }
    floating(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset) {
        if (utils.types.has(region, 'region'))
            return this.floatingRegion(region);
        else
            return this.floatingRegion(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset);
    }
    floatings(regionOrMaxOffset, ...regions) {
        return this.floatingRegions(regionOrMaxOffset, ...regions);
    }
    accessibilityRegion(region, type) {
        if (region) {
            const accessibilityRegion = utils.types.has(region, 'region') ? region : { region, type };
            if (!this._settings.accessibilityRegions)
                this._settings.accessibilityRegions = [];
            this._settings.accessibilityRegions.push(accessibilityRegion);
        }
        return this;
    }
    accessibilityRegions(regionOrType, ...regions) {
        let type;
        if (utils.types.isEnumValue(regionOrType, AccessibilityRegionType_1.AccessibilityRegionTypeEnum)) {
            type = regionOrType;
        }
        else {
            this.accessibilityRegion(regionOrType);
        }
        regions.forEach(region => {
            if (utils.types.has(region, 'region'))
                this.accessibilityRegion(region);
            else
                this.accessibilityRegion(region, type);
        });
        return this;
    }
    dynamicRegion(region, type) {
        if (region) {
            const dynamicRegion = utils.types.has(region, 'region') ? region : { region, type };
            if (!this._settings.dynamicRegions)
                this._settings.dynamicRegions = [];
            this._settings.dynamicRegions.push(dynamicRegion);
        }
        return this;
    }
    dynamicRegions(regionOrTypes, ...regions) {
        let types;
        if (utils.types.isArray(regionOrTypes) || utils.types.isString(regionOrTypes)) {
            types = regionOrTypes;
        }
        else {
            this.dynamicRegions(regionOrTypes);
        }
        regions.forEach(region => {
            if (utils.types.has(region, 'region'))
                this.dynamicRegion(region);
            else
                this.dynamicRegion(region, types);
        });
        return this;
    }
    matchLevel(matchLevel) {
        this._settings.matchLevel = matchLevel;
        return this;
    }
    layout() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Layout;
        return this;
    }
    exact() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Exact;
        return this;
    }
    strict() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Strict;
        return this;
    }
    ignoreColors() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.IgnoreColors;
        return this;
    }
    dynamic() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Dynamic;
        return this;
    }
    /** @deprecated */
    content() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Content;
        return this;
    }
    enablePatterns(enablePatterns = true) {
        this._settings.enablePatterns = enablePatterns;
        return this;
    }
    ignoreDisplacements(ignoreDisplacements = true) {
        this._settings.ignoreDisplacements = ignoreDisplacements;
        return this;
    }
    ignoreCaret(ignoreCaret = true) {
        this._settings.ignoreCaret = ignoreCaret;
        return this;
    }
    useDom(useDom = true) {
        this._settings.useDom = useDom;
        return this;
    }
    sendDom(sendDom = true) {
        this._settings.sendDom = sendDom;
        return this;
    }
    pageId(pageId) {
        this._settings.pageId = pageId;
        return this;
    }
    variationGroupId(variationGroupId) {
        this._settings.variationGroupId = variationGroupId;
        return this;
    }
    /** @internal */
    toObject() {
        return this._settings;
    }
    /** @internal */
    toString() {
        return utils.general.toString(this);
    }
    /** @internal */
    assumesMutability() {
        // if this is a leaf of a linked list (i.e., has no children and all ancestors have exactly one child), them making the CheckSettings mutable is safe
        if (this.childs.length)
            return true;
        for (let parent = this.parent; parent; parent = parent.parent) {
            if (parent.childs.length !== 1)
                return true;
        }
        return undefined;
    }
    static makeMutableTreeProxy(self, ctor) {
        const shouldNotBeProxied = ['assumesMutability', 'childs', 'parent']; // these properties should not be proxied as they are used to determine if the tree is mutable
        const shouldNotCreateChild = ['toObject', 'toJSON', 'toString']; // these properties should not create a child
        return new Proxy(self, {
            get(target, prop, receiver) {
                if (shouldNotBeProxied.includes(String(prop)))
                    return Reflect.get(target, prop, receiver);
                let rootTarget = target;
                while (rootTarget.parent)
                    rootTarget = rootTarget.parent;
                const origProp = Reflect.get(rootTarget, prop, receiver);
                if (typeof origProp !== 'function')
                    return origProp;
                if (shouldNotCreateChild.includes(String(prop)))
                    return origProp;
                return function (...args) {
                    // @ts-ignore
                    const result = origProp.call(rootTarget, ...args);
                    if (result instanceof CheckSettingsBaseFluent) {
                        if (result instanceof CheckSettingsImageFluent || result instanceof CheckSettingsAutomationFluent) {
                            return new ctor(null, null, target);
                        }
                        else {
                            // should not happen - the only known types to be proxied are CheckSettingsImageFluent and CheckSettingsAutomationFluent
                            throw new Error('Unknown CheckSettings type');
                        }
                    }
                    return result;
                };
            },
        });
    }
    // protected toCoreCodedRegion(region: CodedRegion<TRegion>): Core.CodedRegion<TRegion | utils.Region>
    // protected toCoreCodedRegion(region: Region | LegacyRegion | TRegion): utils.Region | TRegion
    toCoreCodedRegion(region) {
        if (utils.types.has(region, ['region'])) {
            return { ...region, region: this.toCoreRegion(region.region) };
        }
        else {
            return this.toCoreRegion(region);
        }
    }
    toCoreCodedFloatingRegion(region) {
        if (utils.types.has(region, 'region')) {
            const { maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset, ...rest } = region;
            return {
                offset: { top: maxUpOffset, bottom: maxDownOffset, left: maxLeftOffset, right: maxRightOffset },
                ...this.toCoreCodedRegion(rest),
            };
        }
        else {
            return this.toCoreRegion(region);
        }
    }
    toCoreRegion(region) {
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            return { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        else {
            return region;
        }
    }
}
exports.CheckSettingsBaseFluent = CheckSettingsBaseFluent;
class CheckSettingsImageFluent extends CheckSettingsBaseFluent {
    constructor(settings, target, parent) {
        super(undefined, parent);
        const self = CheckSettingsBaseFluent.makeMutableTreeProxy(this, CheckSettingsImageFluent);
        this._target = null;
        self._target = target !== null && target !== void 0 ? target : settings === null || settings === void 0 ? void 0 : settings._target;
        self._settings = utils.types.instanceOf(settings, CheckSettingsImageFluent) ? settings.toObject() : settings !== null && settings !== void 0 ? settings : {};
        if (settings instanceof CheckSettingsImageFluent) {
            parent !== null && parent !== void 0 ? parent : (parent = settings.parent);
            // copy constructor does not considered as a new child
            parent === null || parent === void 0 ? void 0 : parent.childs.pop();
        }
        return self;
    }
    image(image) {
        var _a;
        (_a = this._target) !== null && _a !== void 0 ? _a : (this._target = {});
        this._target.image = image;
        return this;
    }
    buffer(imageBuffer) {
        return this.image(imageBuffer);
    }
    base64(imageBase64) {
        return this.image(imageBase64);
    }
    path(imagePath) {
        return this.image(imagePath);
    }
    url(imageUrl) {
        return this.image(imageUrl);
    }
    name(name) {
        this._target.name = name;
        return super.name(name);
    }
    withDom(dom) {
        this._settings.sendDom = true;
        this._target.dom = dom;
        return this;
    }
    withLocation(locationInViewport) {
        this._target.locationInViewport = locationInViewport;
        return this;
    }
    /** @internal */
    toJSON() {
        var _a, _b, _c, _d, _e, _f, _g;
        return {
            target: this._target,
            settings: utils.general.removeUndefinedProps({
                name: this._settings.name,
                region: this._settings.region ? this.toCoreRegion(this._settings.region) : this._settings.region,
                matchLevel: this._settings.matchLevel,
                useDom: this._settings.useDom,
                sendDom: this._settings.sendDom,
                enablePatterns: this._settings.enablePatterns,
                ignoreDisplacements: this._settings.ignoreDisplacements,
                ignoreCaret: this._settings.ignoreCaret,
                ignoreRegions: (_a = this._settings.ignoreRegions) === null || _a === void 0 ? void 0 : _a.map(this.toCoreCodedRegion),
                layoutRegions: (_b = this._settings.layoutRegions) === null || _b === void 0 ? void 0 : _b.map(this.toCoreCodedRegion),
                strictRegions: (_c = this._settings.strictRegions) === null || _c === void 0 ? void 0 : _c.map(this.toCoreCodedRegion),
                contentRegions: (_d = this._settings.contentRegions) === null || _d === void 0 ? void 0 : _d.map(this.toCoreCodedRegion),
                floatingRegions: (_e = this._settings.floatingRegions) === null || _e === void 0 ? void 0 : _e.map(this.toCoreCodedFloatingRegion),
                accessibilityRegions: (_f = this._settings.accessibilityRegions) === null || _f === void 0 ? void 0 : _f.map(this.toCoreCodedRegion),
                dynamicRegions: (_g = this._settings.dynamicRegions) === null || _g === void 0 ? void 0 : _g.map(this.toCoreCodedRegion),
                pageId: this._settings.pageId,
                userCommandId: this._settings.variationGroupId,
                assumesMutability: this.assumesMutability(),
            }),
        };
    }
}
exports.CheckSettingsImageFluent = CheckSettingsImageFluent;
class CheckSettingsAutomationFluent extends CheckSettingsBaseFluent {
    _isElementReference(value) {
        var _a, _b, _c;
        const spec = (_a = this._spec) !== null && _a !== void 0 ? _a : this.constructor._spec;
        return !!((_b = spec.isElement) === null || _b === void 0 ? void 0 : _b.call(spec, value)) || !!((_c = spec.isSecondaryElement) === null || _c === void 0 ? void 0 : _c.call(spec, value)) || this._isSelectorReference(value);
    }
    _isSelectorReference(selector) {
        var _a, _b, _c, _d, _e;
        const spec = (_a = this._spec) !== null && _a !== void 0 ? _a : this.constructor._spec;
        return (!!((_b = spec.isSelector) === null || _b === void 0 ? void 0 : _b.call(spec, selector)) ||
            !!((_c = spec.isSecondarySelector) === null || _c === void 0 ? void 0 : _c.call(spec, selector)) ||
            utils.types.isString(selector) ||
            (utils.types.isPlainObject(selector) &&
                utils.types.has(selector, 'selector') &&
                (utils.types.isString(selector.selector) ||
                    !!((_d = spec.isSelector) === null || _d === void 0 ? void 0 : _d.call(spec, selector.selector)) ||
                    !!((_e = spec.isSecondarySelector) === null || _e === void 0 ? void 0 : _e.call(spec, selector)))));
    }
    _isFrameReference(value) {
        return utils.types.isNumber(value) || utils.types.isString(value) || this._isElementReference(value);
    }
    constructor(settings, spec, parent) {
        super(undefined, parent !== null && parent !== void 0 ? parent : settings === null || settings === void 0 ? void 0 : settings.parent);
        this._settings = null;
        this._spec = null;
        const self = CheckSettingsBaseFluent.makeMutableTreeProxy(this, (CheckSettingsAutomationFluent));
        self._spec = spec;
        self._settings = utils.types.instanceOf(settings, CheckSettingsAutomationFluent)
            ? settings.toObject()
            : settings !== null && settings !== void 0 ? settings : {};
        if (settings instanceof CheckSettingsAutomationFluent) {
            parent !== null && parent !== void 0 ? parent : (parent = settings.parent);
            // copy constructor does not considered as a new child
            parent === null || parent === void 0 ? void 0 : parent.childs.pop();
        }
        return self;
    }
    region(region) {
        if (this._isSelectorReference(region) &&
            this._isSelectorReference(this._settings.region) &&
            utils.types.has(this._settings.region, 'selector')) {
            let lastSelector = this._settings.region;
            while (lastSelector.shadow)
                lastSelector = lastSelector.shadow;
            lastSelector.shadow = region;
            return this;
        }
        return super.region(region);
    }
    shadow(selector) {
        selector = utils.types.has(selector, 'selector') ? selector : { selector };
        if (!this._settings.region) {
            this._settings.region = selector;
        }
        else if (this._isSelectorReference(this._settings.region)) {
            let lastSelector;
            if (utils.types.has(this._settings.region, 'selector')) {
                lastSelector = this._settings.region;
                while (lastSelector.shadow)
                    lastSelector = lastSelector.shadow;
            }
            else {
                lastSelector = { selector: this._settings.region };
            }
            lastSelector.shadow = selector;
        }
        return this;
    }
    frame(contextOrFrame, scrollRootElement) {
        const context = this._isFrameReference(contextOrFrame) || this._isSelectorReference(contextOrFrame)
            ? { frame: contextOrFrame, scrollRootElement }
            : contextOrFrame;
        if (!this._settings.frames)
            this._settings.frames = [];
        this._settings.frames.push(context);
        return this;
    }
    webview(webview) {
        this._settings.webview = webview !== null && webview !== void 0 ? webview : true;
        return this;
    }
    scrollRootElement(scrollRootElement) {
        if (this._settings.frames && this._settings.frames.length > 0) {
            const context = this._settings.frames[this._settings.frames.length - 1];
            context.scrollRootElement = scrollRootElement;
        }
        this._settings.scrollRootElement = scrollRootElement;
        return this;
    }
    fully(fully = true) {
        this._settings.fully = fully;
        return this;
    }
    /** @deprecated */
    stitchContent(stitchContent = true) {
        return this.fully(stitchContent);
    }
    disableBrowserFetching(disableBrowserFetching) {
        this._settings.disableBrowserFetching = disableBrowserFetching;
        return this;
    }
    layoutBreakpoints(breakpoints = true, heightBreakpointsOrSettings, settings) {
        if (utils.types.isBoolean(heightBreakpointsOrSettings)) {
            this._settings.layoutBreakpoints = {
                breakpoints: breakpoints,
                heightBreakpoints: heightBreakpointsOrSettings,
                reload: settings === null || settings === void 0 ? void 0 : settings.reload,
            };
        }
        else {
            this._settings.layoutBreakpoints = {
                breakpoints: utils.types.isArray(breakpoints)
                    ? Array.from(new Set(breakpoints)).sort((a, b) => (a < b ? 1 : -1))
                    : breakpoints,
                reload: heightBreakpointsOrSettings === null || heightBreakpointsOrSettings === void 0 ? void 0 : heightBreakpointsOrSettings.reload,
            };
        }
        return this;
    }
    hook(name, script) {
        this._settings.hooks = { ...this._settings.hooks, [name]: script };
        return this;
    }
    beforeRenderScreenshotHook(script) {
        return this.hook('beforeCaptureScreenshot', script);
    }
    /** @deprecated */
    webHook(script) {
        return this.beforeRenderScreenshotHook(script);
    }
    ufgOption(key, value) {
        this._settings.ufgOptions = { ...this._settings.ufgOptions, [key]: value };
        return this;
    }
    ufgOptions(options) {
        this._settings.ufgOptions = options;
        return this;
    }
    /** @deprecated */
    nmgOption(key, value) {
        this._settings.nmgOptions = { ...this._settings.nmgOptions, [key]: value };
        return this;
    }
    /** @deprecated */
    nmgOptions(options) {
        this._settings.nmgOptions = options;
        return this;
    }
    /** @deprecated */
    visualGridOption(key, value) {
        return this.ufgOption(key, value);
    }
    /** @deprecated */
    visualGridOptions(options) {
        return this.ufgOptions(options);
    }
    useSystemScreenshot(useSystemScreenshot = true) {
        this._settings.useSystemScreenshot = useSystemScreenshot;
        return this;
    }
    timeout(timeout) {
        this._settings.timeout = timeout;
        return this;
    }
    waitBeforeCapture(waitBeforeCapture) {
        this._settings.waitBeforeCapture = waitBeforeCapture;
        return this;
    }
    lazyLoad(options) {
        this._settings.lazyLoad = options !== null && options !== void 0 ? options : true;
        return this;
    }
    densityMetrics(options) {
        this._settings.densityMetrics = options;
        return this;
    }
    stitchMode(stitchMode) {
        this._settings.stitchMode = stitchMode;
        return this;
    }
    /** @internal */
    toLayoutBreakpoints() {
        var _a;
        let layoutBreakpoints;
        if (utils.types.has(this._settings.layoutBreakpoints, 'breakpoints')) {
            layoutBreakpoints = this._settings.layoutBreakpoints;
        }
        else {
            layoutBreakpoints = { breakpoints: (_a = this._settings.layoutBreakpoints) !== null && _a !== void 0 ? _a : false };
        }
        return layoutBreakpoints;
    }
    /** @internal */
    toJSON() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return {
            target: undefined,
            settings: utils.general.removeUndefinedProps({
                name: this._settings.name,
                region: this._settings.region ? this.toCoreRegion(this._settings.region) : this._settings.region,
                frames: this._settings.frames,
                webview: this._settings.webview,
                scrollRootElement: this._settings.scrollRootElement,
                fully: this._settings.fully,
                matchLevel: this._settings.matchLevel,
                useDom: this._settings.useDom,
                sendDom: this._settings.sendDom,
                enablePatterns: this._settings.enablePatterns,
                ignoreDisplacements: this._settings.ignoreDisplacements,
                ignoreCaret: this._settings.ignoreCaret,
                ignoreRegions: (_a = this._settings.ignoreRegions) === null || _a === void 0 ? void 0 : _a.map(this.toCoreCodedRegion),
                layoutRegions: (_b = this._settings.layoutRegions) === null || _b === void 0 ? void 0 : _b.map(this.toCoreCodedRegion),
                strictRegions: (_c = this._settings.strictRegions) === null || _c === void 0 ? void 0 : _c.map(this.toCoreCodedRegion),
                contentRegions: (_d = this._settings.contentRegions) === null || _d === void 0 ? void 0 : _d.map(this.toCoreCodedRegion),
                floatingRegions: (_e = this._settings.floatingRegions) === null || _e === void 0 ? void 0 : _e.map(this.toCoreCodedFloatingRegion),
                accessibilityRegions: (_f = this._settings.accessibilityRegions) === null || _f === void 0 ? void 0 : _f.map(this.toCoreCodedRegion),
                dynamicRegions: (_g = this._settings.dynamicRegions) === null || _g === void 0 ? void 0 : _g.map(this.toCoreCodedRegion),
                disableBrowserFetching: this._settings.disableBrowserFetching,
                layoutBreakpoints: utils.types.isDefined(this._settings.layoutBreakpoints)
                    ? this.toLayoutBreakpoints()
                    : undefined,
                ufgOptions: (_h = this._settings.ufgOptions) !== null && _h !== void 0 ? _h : this._settings.visualGridOptions,
                nmgOptions: this._settings.nmgOptions,
                screenshotMode: this._settings.useSystemScreenshot ? 'default' : undefined,
                hooks: this._settings.hooks,
                pageId: this._settings.pageId,
                lazyLoad: this._settings.lazyLoad,
                waitBeforeCapture: this._settings.waitBeforeCapture,
                retryTimeout: this._settings.timeout,
                userCommandId: this._settings.variationGroupId,
                densityMetrics: this._settings.densityMetrics,
                assumesMutability: this.assumesMutability(),
                stitchMode: this._settings.stitchMode,
            }),
        };
    }
}
exports.CheckSettingsAutomationFluent = CheckSettingsAutomationFluent;
exports.TargetImage = {
    image(image) {
        return new CheckSettingsImageFluent().image(image);
    },
    buffer(imageBuffer) {
        return new CheckSettingsImageFluent().image(imageBuffer);
    },
    base64(imageBase64) {
        return new CheckSettingsImageFluent().image(imageBase64);
    },
    path(imagePath) {
        return new CheckSettingsImageFluent().image(imagePath);
    },
    url(imageUrl) {
        return new CheckSettingsImageFluent().image(imageUrl);
    },
};
exports.TargetAutomation = {
    spec: null,
    window() {
        return new CheckSettingsAutomationFluent({}, this.spec);
    },
    region(region) {
        if (!region) {
            // eslint-disable-next-line no-console
            console.warn('Target.region() called with no region. Will take a screenshot of the entire window instead.');
            // eslint-disable-next-line no-console
            console.trace();
        }
        return new CheckSettingsAutomationFluent({}, this.spec).region(region);
    },
    frame(contextOrFrame, scrollRootElement) {
        return new CheckSettingsAutomationFluent({}, this.spec).frame(contextOrFrame, scrollRootElement);
    },
    shadow(selector) {
        return new CheckSettingsAutomationFluent({}, this.spec).shadow(selector);
    },
    webview(webview) {
        return new CheckSettingsAutomationFluent({}, this.spec).webview(webview);
    },
};
exports.Target = { ...exports.TargetImage, ...exports.TargetAutomation };
