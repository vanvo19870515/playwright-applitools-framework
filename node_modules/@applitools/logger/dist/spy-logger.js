"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSpyLogger = void 0;
const logger_1 = require("./logger");
// @ts-ignore
const promises_1 = require("node:timers/promises");
function makeSpyLogger({ level } = {}) {
    const calls = [];
    const waiter = makeWaiter();
    let loggerExtension = undefined;
    const logger = (0, logger_1.makeLogger)({
        handler: {
            log(message) {
                calls.push({ level: 'info', message });
                loggerExtension === null || loggerExtension === void 0 ? void 0 : loggerExtension.log(message);
                waiter.notifyAll();
            },
            error(message) {
                calls.push({ level: 'error', message });
                loggerExtension === null || loggerExtension === void 0 ? void 0 : loggerExtension.error(message);
                waiter.notifyAll();
            },
            warn(message) {
                calls.push({ level: 'warn', message });
                loggerExtension === null || loggerExtension === void 0 ? void 0 : loggerExtension.warn(message);
                waiter.notifyAll();
            },
            fatal(message) {
                calls.push({ level: 'fatal', message });
                loggerExtension === null || loggerExtension === void 0 ? void 0 : loggerExtension.fatal(message);
                waiter.notifyAll();
            },
        },
        level,
    });
    return {
        ...logger,
        calls,
        waitForNextCall(timeout = 5000) {
            const start = Date.now();
            return waiter.wait(start + timeout, `Timeout waiting for the next logger call. Current calls: ${calls.length}. Timeout: ${timeout}ms`);
        },
        async waitForLength(length, timeout = 5000) {
            const start = Date.now();
            while (calls.length < length) {
                await waiter.wait(start + timeout, `Timeout waiting for logger to have ${length} calls reached. Current calls: ${calls.length}. Timeout: ${timeout}ms`);
            }
        },
        async waitForLog(message, { level, timeout = 5000 } = {}) {
            const start = Date.now();
            while (!calls.some(call => call.message.includes(message) && (!level || call.level === level))) {
                await waiter.wait(start + timeout, `Timeout waiting for logger to have message "${message}". Timeout: ${timeout}ms`);
            }
        },
        extend: (_anotherLogger) => {
            return logger;
        },
        wrap: (anotherLogger) => {
            loggerExtension = anotherLogger;
            return logger;
        },
        get isSpyLogger() {
            return true;
        },
    };
}
exports.makeSpyLogger = makeSpyLogger;
function makeWaiter() {
    const waiters = [];
    return {
        wait(deadline, errorMessage) {
            const timeLeft = deadline - Date.now();
            const abortController = new AbortController();
            if (timeLeft > 0) {
                return Promise.race([
                    new Promise(res => waiters.push(res)),
                    (0, promises_1.setTimeout)(timeLeft, new Error(errorMessage !== null && errorMessage !== void 0 ? errorMessage : `Timeout waiting for logger`), {
                        signal: abortController.signal,
                    }),
                ]).then(error => {
                    abortController.abort();
                    if (error instanceof Error) {
                        throw error;
                    }
                });
            }
            throw new Error(errorMessage !== null && errorMessage !== void 0 ? errorMessage : `Timeout waiting for logger`);
        },
        notifyAll() {
            waiters.splice(0).forEach(res => res());
        },
    };
}
