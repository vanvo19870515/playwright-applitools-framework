"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toGeneratedSelectors = void 0;
function toGeneratedSelectors({ elementReferences, logger, transformElementReference, }) {
    var _a, _b, _c;
    const elementReferencesToMark = [
        (_a = elementReferences.target) !== null && _a !== void 0 ? _a : [],
        (_b = elementReferences.scrolling) !== null && _b !== void 0 ? _b : [],
        (_c = elementReferences.calculate) !== null && _c !== void 0 ? _c : [],
    ].flat();
    return { elementReferencesToMark, getGeneratedSelectors };
    function getGeneratedSelectors(generatedSelectors) {
        var _a, _b, _c;
        let target = undefined;
        let scrolling = undefined;
        let calculate = [];
        if (generatedSelectors) {
            let offset = 0;
            if (elementReferences.target) {
                const targetOrError = (_a = generatedSelectors[offset++].safeSelector) !== null && _a !== void 0 ? _a : undefined;
                if (!targetOrError)
                    throw new Error('Target element not found');
                if (typeof targetOrError !== 'string' && 'error' in targetOrError)
                    throw new Error(`Target element is stale - please make sure the element is not detached from the DOM tree. ${targetOrError.error}`);
                target = targetOrError;
            }
            if (elementReferences.scrolling) {
                const scrollingOrError = (_b = generatedSelectors[offset++].safeSelector) !== null && _b !== void 0 ? _b : undefined;
                const isError = typeof scrollingOrError === 'object' && 'error' in scrollingOrError;
                scrolling = isError ? undefined : scrollingOrError;
                if (isError) {
                    logger.log('Error in scrolling element:', scrollingOrError);
                }
                else if (!scrolling) {
                    logger.log('Scrolling element not found');
                }
            }
            calculate = generatedSelectors.slice(offset).map(generatedSelector => {
                var _a;
                const safeSelector = generatedSelector.safeSelector;
                const isError = safeSelector && typeof safeSelector === 'object' && 'error' in safeSelector;
                if (isError) {
                    logger.log('Error in calculate element:', safeSelector);
                }
                else if (!safeSelector) {
                    logger.log('Calculate element not found', (_a = generatedSelector.originalSelector) !== null && _a !== void 0 ? _a : '');
                }
                return {
                    ...generatedSelector,
                    safeSelector: isError ? null : safeSelector,
                };
            });
        }
        else {
            // the entire else statement should be a dead code that was used for NMG, will be removed later
            target = elementReferences.target && transformElementReference(elementReferences.target);
            scrolling = elementReferences.scrolling && transformElementReference(elementReferences.scrolling);
            calculate = ((_c = elementReferences.calculate) !== null && _c !== void 0 ? _c : []).map(elementReference => {
                var _a;
                const selector = (_a = transformElementReference(elementReference)) !== null && _a !== void 0 ? _a : null;
                return { originalSelector: selector, safeSelector: selector };
            });
        }
        return { target: target, scrolling, calculate };
    }
}
exports.toGeneratedSelectors = toGeneratedSelectors;
