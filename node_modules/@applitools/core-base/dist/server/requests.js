"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeFunctionalSessionRequests = exports.makeEyesRequests = exports.makeCoreRequestsWithCache = void 0;
const req_1 = __importDefault(require("@applitools/req"));
const logger_1 = require("@applitools/logger");
const req_eyes_1 = require("./req-eyes");
const upload_1 = require("./upload");
const utils = __importStar(require("@applitools/utils"));
const server_region_converter_1 = require("../utils/server-region-converter");
const invalidApiKeyError_1 = require("../errors/invalidApiKeyError");
const buffer_1 = require("buffer");
const missingApiKeyError_1 = require("../errors/missingApiKeyError");
const mask_1 = require("../utils/mask");
const chalk_1 = __importDefault(require("chalk"));
exports.makeCoreRequestsWithCache = utils.general.cachify(makeCoreRequests, () => 'default');
function makeCoreRequests({ fetch, logger: defaultLogger } = {}) {
    const mainLogger = (0, logger_1.makeLogger)({ logger: defaultLogger, format: { label: 'core-requests' } });
    const supportsOpenCheckAndClose = new Map();
    const getAccountInfoWithCache = utils.general.cachify(getAccountInfo, ([{ settings }]) => {
        return [settings.eyesServerUrl, settings.apiKey, settings.proxy];
    });
    const updateIfScmWithCache = utils.general.cachify(updateIfScm, ([{ settings }]) => {
        return [settings.batchId, settings.eyesServerUrl, settings.apiKey, settings.proxy];
    });
    const logEvent = utils.general.batchify(logEventBatch, { timeout: 200, maxPending: 100 }); // log up to 100 events in a single request (the server supports 1000)
    const core = {
        concurrency: undefined,
        getAccountInfo: getAccountInfoWithCache,
        updateIfScm: updateIfScmWithCache,
        openEyes,
        openFunctionalSession,
        openCheckAndClose,
        locate,
        locateText,
        extractText,
        closeBatch,
        deleteTest,
        logEvent,
        sendHeartbeat,
        openCheckAndCloseEyes,
    };
    return core;
    async function openEyes({ settings, heartbeat, logger = mainLogger, }) {
        var _a;
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "openEyes" called with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        if (account.processKeepaliveIntervalSec) {
            heartbeat.startPeriodicHeartbeatMessaging({
                eyesServerUrl: settings.eyesServerUrl,
                apiKey: settings.apiKey,
                proxy: settings.proxy,
                useDnsCache: settings.useDnsCache,
                agentId: settings.agentId,
                processId: settings.processId,
                interval: (_a = utils.general.getEnvValue('HEARTBEAT_INTERVAL', 'number')) !== null && _a !== void 0 ? _a : account.processKeepaliveIntervalSec * 1000,
            });
        }
        const initializedAt = new Date().toISOString();
        const response = await req('./api/sessions/running', {
            name: 'openEyes',
            method: 'POST',
            body: {
                startInfo: toStartInfo({ settings }),
            },
            expected: [200, 201],
            logger,
        });
        const test = await response.json().then(async (result) => {
            var _a, _b, _c;
            return {
                testId: result.id,
                // TODO revisit the need for it
                testName: settings.testName,
                userTestId: settings.userTestId,
                batchId: (_b = (_a = settings.batch) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : result.batchId,
                baselineId: result.baselineId,
                sessionId: result.sessionId,
                initializedAt,
                appId: settings.appName,
                isNew: (_c = result.isNew) !== null && _c !== void 0 ? _c : response.status === 201,
                keepBatchOpen: !!settings.keepBatchOpen,
                keepIfDuplicate: !!settings.baselineEnvName,
                resultsUrl: result.url,
                eyesServer: account.eyesServer,
                ufgServer: account.ufgServer,
                uploadUrl: account.uploadUrl,
                supportedEnvironmentsUrl: account.supportedEnvironmentsUrl,
                stitchingServiceUrl: account.stitchingServiceUrl,
                account,
                environment: settings.environment,
                trimmedBatchProps: result.trimmedBatchProps,
            };
        });
        logger.log('Request "openEyes" finished successfully with body', test);
        if (test.trimmedBatchProps) {
            // Destructure for cleaner access to the limit values
            const { maxNameLength, maxValueLength, maxTotalLength } = account.batchPropertiesLimits;
            logger.console.log(chalk_1.default.yellow(`You've exceeded the allowed number of characters for test or batch properties:️\n` +
                `  > Max Name Length: ${maxNameLength}\n` +
                `  > Max Value Length: ${maxValueLength}\n` +
                `  > Max Total Length: ${maxTotalLength}`));
        }
        return makeEyesRequests({ core, test, req, logger });
    }
    async function openFunctionalSession({ settings, logger = mainLogger, }) {
        var _a, _b, _c, _d, _e;
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "openFunctionalSession" called with settings', settings);
        const accountPromise = getAccountInfoWithCache({ settings });
        const initializedAt = new Date().toISOString();
        const response = await req('./api/sessions/running', {
            name: 'openFunctionalSession',
            method: 'POST',
            body: {
                startInfo: {
                    agentId: settings.agentId,
                    agentSessionId: settings.userTestId,
                    agentRunId: settings.userTestId,
                    sessionType: settings.sessionType,
                    appIdOrName: settings.appName,
                    scenarioIdOrName: settings.testName,
                    displayName: settings.displayName,
                    properties: [...((_a = settings.properties) !== null && _a !== void 0 ? _a : []), ...((_c = (_b = settings.environment) === null || _b === void 0 ? void 0 : _b.properties) !== null && _c !== void 0 ? _c : [])],
                    batchInfo: settings.batch && {
                        id: settings.batch.id,
                        name: settings.batch.name,
                        batchSequenceName: settings.batch.sequenceName,
                        startedAt: settings.batch.startedAt,
                        notifyOnCompletion: settings.batch.notifyOnCompletion,
                        properties: settings.batch.properties,
                        buildId: settings.batch.buildId,
                    },
                    egSessionId: (_e = (_d = settings.environment) === null || _d === void 0 ? void 0 : _d.ecSessionId) !== null && _e !== void 0 ? _e : null,
                    environment: settings.environment &&
                        (settings.environment.rawEnvironment
                            ? {
                                ...settings.environment.rawEnvironment,
                                os: settings.environment.os,
                                osInfo: settings.environment.displayOs,
                                hostingApp: settings.environment.hostingApp,
                                hostingAppInfo: settings.environment.displayHostingApp,
                            }
                            : {
                                deviceInfo: settings.environment.deviceName,
                                os: settings.environment.os,
                                osInfo: settings.environment.displayOs,
                                hostingApp: settings.environment.hostingApp,
                                hostingAppInfo: settings.environment.displayHostingApp,
                                displaySize: settings.environment.viewportSize
                                    ? utils.geometry.round(settings.environment.viewportSize)
                                    : { width: 0, height: 0 },
                                inferred: settings.environment.userAgent && `useragent:${settings.environment.userAgent}`,
                            }),
                    timeout: settings.abortIdleTestTimeout,
                    nonVisual: true,
                },
            },
            expected: [200, 201],
            logger,
        });
        const test = await response.json().then(async (result) => {
            var _a, _b;
            const account = await accountPromise;
            return {
                testId: result.id,
                userTestId: settings.userTestId,
                batchId: (_b = (_a = settings.batch) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : result.batchId,
                sessionId: result.sessionId,
                appId: settings.appName,
                resultsUrl: result.url,
                initializedAt,
                keepBatchOpen: !!settings.keepBatchOpen,
                keepIfDuplicate: !!settings.baselineEnvName,
                eyesServer: account.eyesServer,
                account,
                environment: settings.environment,
            };
        });
        logger.log('Request "openFunctionalSession" finished successfully with body', test);
        return makeFunctionalSessionRequests({ core, test, req, logger });
    }
    async function openCheckAndClose({ target, settings, logger = mainLogger, }) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "openCheckAndClose" called with settings', settings);
        const account = await getAccountInfoWithCache({ settings, logger });
        const upload = (0, upload_1.makeUpload)({
            settings: { uploadUrl: account.uploadUrl, proxy: settings.proxy },
            logger: mainLogger,
        });
        [target.image, target.dom, settings.domMapping] = await Promise.all([
            upload({ name: 'image', resource: target.image, logger }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true, logger }),
            settings.domMapping && upload({ name: 'domMapping', resource: settings.domMapping, gzip: true, logger }),
        ]);
        const matchOptions = toServerMatchOptions({ target, settings });
        const openCheckAndCloseResponse = req('./api/sessions/autonomous-start-match-end', {
            name: 'openCheckAndClose',
            method: 'POST',
            body: {
                startInfo: {
                    agentId: settings.agentId,
                    agentSessionId: settings.userTestId,
                    agentRunId: settings.userTestId,
                    sessionType: settings.sessionType,
                    appIdOrName: settings.appName,
                    scenarioIdOrName: settings.testName,
                    displayName: settings.displayName,
                    properties: [...((_a = settings.properties) !== null && _a !== void 0 ? _a : []), ...((_c = (_b = settings.environment) === null || _b === void 0 ? void 0 : _b.properties) !== null && _c !== void 0 ? _c : [])],
                    batchInfo: settings.batch && {
                        id: settings.batch.id,
                        name: settings.batch.name,
                        batchSequenceName: settings.batch.sequenceName,
                        startedAt: settings.batch.startedAt,
                        notifyOnCompletion: settings.batch.notifyOnCompletion,
                        properties: settings.batch.properties,
                        buildId: settings.batch.buildId,
                    },
                    egSessionId: (_e = (_d = settings.environment) === null || _d === void 0 ? void 0 : _d.ecSessionId) !== null && _e !== void 0 ? _e : null,
                    environment: settings.environment &&
                        (settings.environment.rawEnvironment
                            ? {
                                ...settings.environment.rawEnvironment,
                                os: (_f = settings.environment.os) !== null && _f !== void 0 ? _f : settings.environment.rawEnvironment.os,
                                osInfo: (_g = settings.environment.displayOs) !== null && _g !== void 0 ? _g : settings.environment.rawEnvironment.osInfo,
                                hostingApp: (_h = settings.environment.hostingApp) !== null && _h !== void 0 ? _h : settings.environment.rawEnvironment.hostingApp,
                                hostingAppInfo: (_j = settings.environment.displayHostingApp) !== null && _j !== void 0 ? _j : settings.environment.rawEnvironment.hostingAppInfo,
                            }
                            : {
                                deviceInfo: settings.environment.deviceName,
                                os: settings.environment.os,
                                osInfo: settings.environment.displayOs,
                                hostingApp: settings.environment.hostingApp,
                                hostingAppInfo: settings.environment.displayHostingApp,
                                displaySize: settings.environment.viewportSize
                                    ? utils.geometry.round(settings.environment.viewportSize)
                                    : { width: 0, height: 0 },
                                inferred: settings.environment.userAgent && `useragent:${settings.environment.userAgent}`,
                            }),
                    environmentName: settings.environmentName,
                    baselineEnvName: settings.baselineEnvName,
                    branchName: settings.branchName,
                    parentBranchName: settings.parentBranchName,
                    baselineBranchName: settings.baselineBranchName,
                    compareWithParentBranch: settings.compareWithParentBranch,
                    parentBranchBaselineSavedBefore: settings.gitBranchingTimestamp,
                    ignoreBaseline: settings.ignoreBaseline,
                    saveDiffs: settings.saveDiffs,
                    timeout: settings.abortIdleTestTimeout,
                    isComponentAgent: settings.isComponentTest,
                    fallbackExpectedOutput: settings.fallbackBaselineId,
                    latestCommitInfo: settings.latestCommitInfo,
                    processId: settings.processId,
                    replaceExisting: settings.removeDuplicateTests,
                },
                ...matchOptions,
                options: {
                    ...matchOptions.options,
                },
                removeSession: false,
                removeSessionIfMatching: settings.ignoreMismatch,
                updateBaselineIfNew: settings.updateBaselineIfNew,
                updateBaselineIfDifferent: settings.updateBaselineIfDifferent,
            },
            expected: [200, 201],
            logger,
        });
        return openCheckAndCloseResponse.then(() => {
            logger.log('Request "openCheckAndCloseResponse" finished successfully');
        });
    }
    async function locate({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "locate" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ settings: { uploadUrl: account.uploadUrl, proxy: account.eyesServer.proxy }, logger });
        target.image = await upload({ name: 'image', resource: target.image });
        const response = await req('./api/locators/locate', {
            name: 'locate',
            method: 'POST',
            body: {
                imageUrl: target.image,
                appName: settings.appName,
                locatorNames: settings.locatorNames,
                firstOnly: settings.firstOnly,
            },
            expected: 200,
            logger,
        });
        const result = await response.json().then((results) => {
            return settings.locatorNames.reduce((regions, locatorName) => {
                var _a, _b;
                regions[locatorName] = (_b = (((_a = results[locatorName]) !== null && _a !== void 0 ? _a : []))) === null || _b === void 0 ? void 0 : _b.map(region => ({ x: region.left, y: region.top, width: region.width, height: region.height })).sort((region1, region2) => {
                    if (region1.y !== region2.y)
                        return region1.y > region2.y ? 1 : -1;
                    else
                        return region1.x > region2.x ? 1 : -1;
                });
                return regions;
            }, {});
        });
        logger.log('Request "locate" finished successfully with body', result);
        return result;
    }
    async function locateText({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "locateText" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ settings: { uploadUrl: account.uploadUrl, proxy: account.eyesServer.proxy }, logger });
        [target.image, target.dom] = await Promise.all([
            upload({ name: 'image', resource: target.image }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true }),
        ]);
        const response = await req('./api/sessions/running/images/textregions', {
            name: 'locateText',
            method: 'POST',
            body: {
                appOutput: {
                    screenshotUrl: target.image,
                    domUrl: target.dom,
                    location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
                },
                patterns: settings.patterns,
                ignoreCase: settings.ignoreCase,
                firstOnly: settings.firstOnly,
                language: settings.language,
            },
            expected: 200,
            logger,
        });
        const result = await response.json();
        logger.log('Request "locateText" finished successfully with body', result);
        return result;
    }
    async function extractText({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "extractText" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ settings: { uploadUrl: account.uploadUrl, proxy: account.eyesServer.proxy }, logger });
        [target.image, target.dom] = await Promise.all([
            upload({ name: 'image', resource: target.image }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true }),
        ]);
        const response = await req('./api/sessions/running/images/text', {
            name: 'extractText',
            method: 'POST',
            body: {
                appOutput: {
                    screenshotUrl: target.image,
                    domUrl: target.dom,
                    location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
                },
                regions: target.size && [{ left: 0, top: 0, ...utils.geometry.round(target.size), expected: settings.hint }],
                minMatch: settings.minMatch,
                language: settings.language,
            },
            expected: 200,
            logger,
        });
        const result = await response.json();
        logger.log('Request "extractText" finished successfully with body', result);
        return result;
    }
    async function getAccountInfo({ settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "getAccountInfo" called with settings', settings);
        const response = await req('./api/sessions/renderinfo', {
            name: 'getAccountInfo',
            method: 'GET',
            expected: 200,
            logger,
        });
        const res = (await response.json());
        const { serviceUrl: ufgServerUrl, serviceUrlNew: ufgServerUrlNew, accessToken, mobileDevicesListUrl: supportedEnvironmentsUrl, resultsUrl: uploadUrl, ...rest } = res;
        const result = {
            eyesServer: {
                eyesServerUrl: settings.eyesServerUrl,
                apiKey: settings.apiKey,
                agentId: settings.agentId,
                proxy: settings.proxy,
                useDnsCache: settings.useDnsCache,
            },
            ufgServer: {
                ufgServerUrl: await getServiceUrl({ ufgServerUrl, ufgServerUrlNew, eyesServer: settings }, logger),
                accessToken,
                agentId: settings.agentId,
                proxy: settings.proxy,
                useDnsCache: settings.useDnsCache,
            },
            supportedEnvironmentsUrl,
            uploadUrl,
            ...rest,
        };
        logger.mask(result.ufgServer.accessToken);
        logger.log('Request "getAccountInfo" finished successfully with body', result);
        async function getServiceUrl(settings, logger) {
            const serviceUrlNew = await checkServiceUrl(settings.ufgServerUrlNew, settings.eyesServer, logger);
            if (serviceUrlNew) {
                logger.log('Using a new UFG service.', { previous: settings.ufgServerUrl, current: serviceUrlNew });
                return serviceUrlNew;
            }
            return settings.ufgServerUrl;
        }
        async function checkServiceUrl(serviceUrl, settings, logger) {
            return new Promise(async (resolve) => {
                try {
                    if (!serviceUrl)
                        return resolve(undefined);
                    const response = await (0, req_1.default)(serviceUrl, {
                        method: 'GET',
                        connectionTimeout: 2000,
                    });
                    // If the service is not blocked, the response status will be 404
                    if (response && ((response.status >= 200 && response.status < 300) || response.status === 404)) {
                        logger.log(`UFG 'serviceUrlNew' is available, using: ${serviceUrl}`);
                        logEvent({
                            settings: {
                                level: 'Info',
                                event: {
                                    type: 'serviceUrlNew',
                                    message: `UFG 'serviceUrlNew' is available`,
                                    serviceUrlNew: serviceUrl,
                                },
                                eyesServerUrl: settings.eyesServerUrl,
                                apiKey: settings.apiKey,
                            },
                        }).catch(err => logger.log('Error logging event', { error: err, event: `UFG 'serviceUrlNew' is available` }));
                        return resolve(serviceUrl);
                    }
                    else {
                        logger.log(`UFG 'serviceUrlNew' is blocked`);
                        logEvent({
                            settings: {
                                level: 'Notice',
                                event: {
                                    type: 'serviceUrlNew',
                                    message: `UFG 'serviceUrlNew' is blocked`,
                                    serviceUrlNew: serviceUrl,
                                },
                                eyesServerUrl: settings.eyesServerUrl,
                                apiKey: settings.apiKey,
                            },
                        }).catch(err => logger.log('Error logging event', { error: err, event: `UFG 'serviceUrlNew' is blocked` }));
                        return resolve(undefined);
                    }
                }
                catch (error) {
                    logger.error(error);
                    logEvent({
                        settings: {
                            level: 'Notice',
                            event: {
                                type: 'serviceUrlNew',
                                message: `an error occured while accessing to UFG 'serviceUrlNew', the url is probably blocked`,
                                serviceUrlNew: serviceUrl,
                                error: error.message,
                            },
                            eyesServerUrl: settings.eyesServerUrl,
                            apiKey: settings.apiKey,
                        },
                    }).catch(err => logger.log('Error logging event', {
                        error: err,
                        event: `an error occured while accessing to UFG 'serviceUrlNew', the url is probably blocked`,
                    }));
                    return resolve(undefined);
                }
            });
        }
        return result;
    }
    async function updateIfScm({ settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        const requestApiKey = settings.apiKey;
        logger.log('Request "updateIfScm" called with settings', settings);
        const response = await req(`./api/scm-integrations/batches/${settings.batchId}/update-if-scm`, {
            name: 'updateIfScm',
            method: 'POST',
            body: {
                commitSha: settings.batchId,
                buildId: settings.buildId,
                repoOwner: settings.repoOwner,
                repoName: settings.repoName,
                branchName: settings.branchName,
            },
            logger,
        });
        const buff = buffer_1.Buffer.from(await response.arrayBuffer());
        logger.log('Request "updateIfScm" buffer', buff);
        const result = buff.byteLength ? JSON.parse(buff.toString()) : null;
        if (utils.types.isString(result) || (response === null || response === void 0 ? void 0 : response.status) === 401) {
            if (!requestApiKey || requestApiKey === 'undefined') {
                throw new missingApiKeyError_1.MissingApiKeyError();
            }
            else {
                throw new invalidApiKeyError_1.InvalidApiKeyError({ maskedApiKey: (0, mask_1.maskApiKey)(requestApiKey) });
            }
        }
        logger.log('Request "updateIfScm" finished successfully with body', result);
        return result;
    }
    async function closeBatch({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "closeBatch" called with settings', settings);
        await req(settings.batchBuildId
            ? `./api/sessions/batches/${settings.batchId}/${settings.batchBuildId}/close/bypointerId`
            : `./api/sessions/batches/${settings.batchId}/close/bypointerId`, {
            name: 'closeBatch',
            method: 'DELETE',
            expected: 200,
            logger,
        });
        logger.log('Request "closeBatch" finished successfully');
    }
    async function deleteTest({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "deleteTest" called with settings', settings);
        await req(`./api/sessions/batches/${settings.batchId}/${settings.testId}`, {
            name: 'deleteTest',
            method: 'DELETE',
            query: {
                accessToken: settings.secretToken,
            },
            expected: 200,
            logger,
        });
        logger.log('Request "deleteTest" finished successfully');
    }
    async function logEventBatch(batch) {
        const logger = batch
            .map(([{ logger }]) => logger)
            .reduce((acc, logger) => (logger ? acc.extend(logger) : acc), mainLogger)
            .extend({ tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings: batch[0][0].settings, fetch, logger });
        logger.log('Request "logEventBatch" called with settings', batch);
        const events = batch.map(([{ settings }]) => {
            var _a, _b;
            return {
                event: settings.event,
                level: (_a = settings.level) !== null && _a !== void 0 ? _a : 'Info',
                timestamp: (_b = settings.timestamp) !== null && _b !== void 0 ? _b : new Date().toISOString(),
            };
        });
        try {
            await req(`./api/sessions/log`, {
                name: 'logEventBatch',
                method: 'POST',
                body: {
                    events: events,
                },
                expected: 200,
                logger,
            });
            logger.log('Request "logEventBatch" finished successfully');
            batch.forEach(([, { resolve }]) => resolve());
        }
        catch (error) {
            logger.log('Request "logEventBatch" failed', error);
            batch.forEach(([, { reject }]) => reject(error));
        }
    }
    async function sendHeartbeat({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({
            settings: { ...settings, requestTimeout: settings.interval, retry: { limit: 0 } },
            fetch,
            logger,
        });
        logger.log('Request "heartbeat" called with settings', settings);
        await req(`./api/sessions/sdkprocess/keepalive`, {
            name: 'heartbeat',
            method: 'POST',
            body: {
                processId: settings.processId,
            },
            hooks: {
                afterError({ error }) {
                    if (error.message.includes('Bad Request(400)')) {
                        error.message = 'This process is expired. All its sessions were abandoned';
                    }
                },
            },
            expected: 200,
            logger,
        });
        logger.log('Request "heartbeat" finished successfully');
    }
    async function openCheckAndCloseEyes({ target, settings, logger = mainLogger, heartbeat, }) {
        var _a;
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        if (supportsOpenCheckAndClose.get(settings.eyesServerUrl) === false) {
            logger.log('Request "openCheckAndClose" is not supported by the server, using "open" and "checkAndClose" requests instead');
            const eyes = await openEyes({ settings, logger, heartbeat });
            await eyes.checkAndClose({ target, settings, logger });
            return eyes;
        }
        logger.log('Request "openCheckAndClose" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        if (account.processKeepaliveIntervalSec) {
            heartbeat.startPeriodicHeartbeatMessaging({
                eyesServerUrl: settings.eyesServerUrl,
                apiKey: settings.apiKey,
                proxy: settings.proxy,
                useDnsCache: settings.useDnsCache,
                agentId: settings.agentId,
                processId: settings.processId,
                interval: (_a = utils.general.getEnvValue('HEARTBEAT_INTERVAL', 'number')) !== null && _a !== void 0 ? _a : account.processKeepaliveIntervalSec * 1000,
            });
        }
        logger.log('uploading image and dom');
        const upload = (0, upload_1.makeUpload)({
            settings: { uploadUrl: account.uploadUrl, proxy: settings.proxy },
            logger: mainLogger,
        });
        [target.image, target.dom, settings.domMapping] = await Promise.all([
            upload({ name: 'image', resource: target.image, logger }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true, logger }),
            settings.domMapping && upload({ name: 'domMapping', resource: settings.domMapping, gzip: true, logger }),
        ]);
        logger.log('image and dom uploaded');
        const matchOptions = toServerMatchOptions({ target, settings });
        const resultResponsePromise = req(`./api/sessions/match-as-session`, {
            name: 'openCheckAndClose',
            method: 'POST',
            body: {
                startInfo: toStartInfo({ settings }),
                ...matchOptions,
                options: {
                    ...matchOptions.options,
                },
                removeSession: false,
                removeSessionIfMatching: settings.ignoreMismatch,
                updateBaselineIfNew: settings.updateBaselineIfNew,
                updateBaselineIfDifferent: settings.updateBaselineIfDifferent,
            },
            hooks: {
                beforeRetry({ response, stop }) {
                    if ((response === null || response === void 0 ? void 0 : response.status) === 404)
                        return stop;
                },
            },
            expected: [200, 404],
            logger,
        })
            .then(async (response) => {
            if (response.status === 404) {
                supportsOpenCheckAndClose.set(settings.eyesServerUrl, false);
                logger.log('Request "openCheckAndClose" is not supported by the server - retrying with fallback');
                return openCheckAndCloseEyes({ target, settings, logger, heartbeat });
            }
            else {
                logger.log('Request "openCheckAndClose" finished successfully');
                return response;
            }
        })
            .catch(e => (logger.log('Request "openCheckAndClose" failed', e), e));
        return {
            getResults: async () => {
                return resultResponsePromise.then(async (response) => {
                    if (!response || response instanceof Error) {
                        logger.log('Failed to get results, response is ', response);
                        throw new Error(`Failed to get results, response is ${response}`);
                    }
                    if ('getResults' in response)
                        return response.getResults();
                    const result = await response.json().then((result) => {
                        var _a;
                        logger.mask(result.secretToken);
                        result.userTestId = settings.userTestId;
                        // for backwards compatibility with outdated servers
                        (_a = result.status) !== null && _a !== void 0 ? _a : (result.status = result.missing === 0 && result.mismatches === 0 ? 'Passed' : 'Unresolved');
                        return [
                            {
                                ...result,
                                url: result.appUrls.session,
                                isNew: result.new > 0,
                                eyesServer: {
                                    eyesServerUrl: settings.eyesServerUrl,
                                    apiKey: settings.apiKey,
                                    agentId: settings.agentId,
                                    proxy: settings.proxy,
                                    useDnsCache: settings.useDnsCache,
                                },
                            },
                        ];
                    });
                    logger.log('Request "getResults" finished successfully with body', result);
                    return result;
                });
            },
        };
    }
}
function makeEyesRequests({ core, test, req: defaultReq, fetch, logger: mainLogger, }) {
    let resultResponsePromise;
    let supportsCheckAndClose = true;
    let abortReason;
    const req = defaultReq !== null && defaultReq !== void 0 ? defaultReq : (0, req_eyes_1.makeReqEyes)({ settings: test.eyesServer, fetch, logger: mainLogger });
    const upload = (0, upload_1.makeUpload)({
        settings: { uploadUrl: test.account.uploadUrl, proxy: test.eyesServer.proxy },
        logger: mainLogger,
    });
    const eyes = {
        core,
        test,
        get running() {
            return !resultResponsePromise;
        },
        check,
        checkAndClose,
        report,
        close,
        abort,
        getResults,
    };
    return eyes;
    async function check({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log('Request "check" called for target', target, 'with settings', settings);
        [target.image, target.dom, settings.domMapping] = await Promise.all([
            upload({ name: 'image', resource: target.image, logger }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true, logger }),
            settings.domMapping && upload({ name: 'domMapping', resource: settings.domMapping, gzip: true, logger }),
        ]);
        const response = await req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'check',
            method: 'POST',
            body: toServerMatchOptions({ target, settings }),
            expected: 200,
            logger,
        });
        const result = (await response.json());
        logger.log('Request "check" finished successfully with body', result);
        return {
            userTestId: test.userTestId,
            ...result,
        };
    }
    async function checkAndClose({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        if (!supportsCheckAndClose) {
            logger.log('Request "checkAndClose" is not supported by the server, using "check" and "close" requests instead');
            await check({ target, settings, logger });
            return close({ settings, logger });
        }
        logger.log('Request "checkAndClose" called for target', target, 'with settings', settings);
        [target.image, target.dom, settings.domMapping] = await Promise.all([
            upload({ name: 'image', resource: target.image, logger }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true, logger }),
            settings.domMapping && upload({ name: 'domMapping', resource: settings.domMapping, gzip: true, logger }),
        ]);
        const matchOptions = toServerMatchOptions({ target, settings });
        resultResponsePromise = req(`./api/sessions/running/${encodeURIComponent(test.testId)}/matchandend`, {
            name: 'checkAndClose',
            method: 'POST',
            body: {
                ...matchOptions,
                options: {
                    ...matchOptions.options,
                },
                removeSession: false,
                removeSessionIfMatching: settings.ignoreMismatch,
                updateBaselineIfNew: settings.updateBaselineIfNew,
                updateBaselineIfDifferent: settings.updateBaselineIfDifferent,
            },
            hooks: {
                beforeRetry({ response, stop }) {
                    if ((response === null || response === void 0 ? void 0 : response.status) === 404)
                        return stop;
                },
            },
            expected: 200,
            logger,
        });
        return resultResponsePromise
            .then(response => {
            if (response.status === 404) {
                supportsCheckAndClose = false;
                return checkAndClose({ target, settings });
            }
            else {
                logger.log('Request "checkAndClose" finished successfully');
            }
        })
            .catch(() => undefined);
    }
    async function close({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "close" called for test ${test.testId} with settings`, settings);
        if (resultResponsePromise) {
            logger.log(`Request "close" called for test ${test.testId} that was already stopped`);
            return;
        }
        resultResponsePromise = report({ settings, logger }).then(() => req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'close',
            method: 'DELETE',
            query: {
                aborted: false,
                updateBaseline: test.isNew ? settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfNew : settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfDifferent,
            },
            expected: 200,
            logger,
        }));
        return resultResponsePromise
            .then(() => {
            logger.log('Request "close" finished successfully');
        })
            .catch(() => undefined);
    }
    async function abort({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "abort" called for test ${test.testId} with settings`, settings);
        if (resultResponsePromise) {
            logger.log(`Request "abort" called for test ${test.testId} that was already stopped`);
            return;
        }
        abortReason = settings === null || settings === void 0 ? void 0 : settings.reason;
        resultResponsePromise = report({ settings, logger }).then(() => req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'abort',
            method: 'DELETE',
            query: {
                aborted: true,
            },
            expected: 200,
            logger,
        }));
        return resultResponsePromise
            .then(() => {
            logger.log('Request "abort" finished successfully');
        })
            .catch(() => undefined);
    }
    async function getResults({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "getResults" called for test ${test.testId} with settings`, settings);
        if (!resultResponsePromise) {
            logger.warn(`The test with id "${test.testId}" is going to be auto aborted`);
            await abort({ settings, logger });
        }
        const response = await resultResponsePromise;
        if (test.results)
            return await test.results;
        test.results = response
            .json()
            .then((result) => {
            var _a;
            logger.mask(result.secretToken);
            result.userTestId = test.userTestId;
            result.url = test.resultsUrl;
            result.isNew = test.isNew;
            result.initializedAt = test.initializedAt;
            result.keepIfDuplicate = test.keepIfDuplicate;
            result.eyesServer = test.eyesServer;
            result.reason = abortReason;
            // for backwards compatibility with outdated servers
            (_a = result.status) !== null && _a !== void 0 ? _a : (result.status = result.missing === 0 && result.mismatches === 0 ? 'Passed' : 'Unresolved');
            return [result];
        })
            .then(results => {
            logger.log('Request "getResults" finished successfully with body', results);
            return results;
        });
        return await test.results;
    }
    async function report({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger);
        logger.log(`Request "report" called for test ${test.testId} with settings`, settings);
        if (!(settings === null || settings === void 0 ? void 0 : settings.testMetadata) || utils.types.isEmpty(settings.testMetadata))
            return;
        try {
            await req(`./api/sessions/running/${encodeURIComponent(test.testId)}/selfhealdata`, {
                name: 'reportSelfHealing',
                method: 'PUT',
                body: {
                    operations: settings.testMetadata.map(item => {
                        return { old: item === null || item === void 0 ? void 0 : item.originalSelector, new: item === null || item === void 0 ? void 0 : item.successfulSelector, timestamp: new Date().toISOString() };
                    }),
                },
                expected: 200,
                logger,
            });
        }
        catch (error) {
            logger.warn(error);
        }
    }
}
exports.makeEyesRequests = makeEyesRequests;
function makeFunctionalSessionRequests({ core, test, req: defaultReq, fetch, logger: mainLogger, }) {
    let resultResponsePromise;
    const req = defaultReq !== null && defaultReq !== void 0 ? defaultReq : (0, req_eyes_1.makeReqEyes)({ settings: test.eyesServer, fetch, logger: mainLogger });
    const functionalSession = {
        core,
        test,
        get running() {
            return !resultResponsePromise;
        },
        report,
        close,
        abort,
        getResults,
    };
    return functionalSession;
    async function close({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "close" called for test ${test.testId} with settings`, settings);
        if (resultResponsePromise) {
            logger.log(`Request "close" called for test ${test.testId} that was already stopped`);
            return;
        }
        resultResponsePromise = report({ settings, logger }).then(() => {
            var _a;
            return req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
                name: 'close',
                method: 'DELETE',
                query: { aborted: false, nonVisualStatus: (_a = settings === null || settings === void 0 ? void 0 : settings.status) !== null && _a !== void 0 ? _a : 'Completed' },
                expected: 200,
                logger,
            });
        });
        return resultResponsePromise
            .then(() => {
            logger.log('Request "close" finished successfully');
        })
            .catch(() => undefined);
    }
    async function abort({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "abort" called for test ${test.testId} with settings`, settings);
        if (resultResponsePromise) {
            logger.log(`Request "abort" called for test ${test.testId} that was already stopped`);
            return;
        }
        resultResponsePromise = report({ settings, logger }).then(() => req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'abort',
            method: 'DELETE',
            query: {
                aborted: true,
            },
            expected: 200,
            logger,
        }));
        return resultResponsePromise
            .then(() => {
            logger.log('Request "abort" finished successfully');
        })
            .catch(() => undefined);
    }
    async function getResults({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "getResults" called for test ${test.testId} with settings`, settings);
        if (!resultResponsePromise) {
            logger.warn(`The test with id "${test.testId}" is going to be auto aborted`);
            await abort({ settings, logger });
        }
        const response = await resultResponsePromise;
        const results = await response.json().then((result) => {
            logger.mask(result.secretToken);
            result.userTestId = test.userTestId;
            result.url = test.resultsUrl;
            result.initializedAt = test.initializedAt;
            result.keepIfDuplicate = test.keepIfDuplicate;
            result.eyesServer = test.eyesServer;
            return [result];
        });
        logger.log('Request "getResults" finished successfully with body', results);
        return results;
    }
    async function report({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "report" called for test ${test.testId} with settings`, settings);
        if (!(settings === null || settings === void 0 ? void 0 : settings.testMetadata) || utils.types.isEmpty(settings.testMetadata))
            return;
        try {
            await req(`./api/sessions/running/${encodeURIComponent(test.testId)}/selfhealdata`, {
                name: 'reportSelfHealing',
                method: 'PUT',
                body: {
                    operations: settings.testMetadata.map(item => {
                        return { old: item === null || item === void 0 ? void 0 : item.originalSelector, new: item === null || item === void 0 ? void 0 : item.successfulSelector, timestamp: new Date().toISOString() };
                    }),
                },
                expected: 200,
                logger,
            });
        }
        catch (error) {
            logger.warn(error);
        }
    }
}
exports.makeFunctionalSessionRequests = makeFunctionalSessionRequests;
function toStartInfo({ settings }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    return {
        agentId: settings.agentId,
        agentSessionId: settings.userTestId,
        agentRunId: settings.userTestId,
        sessionType: settings.sessionType,
        appIdOrName: settings.appName,
        scenarioIdOrName: settings.testName,
        displayName: settings.displayName,
        properties: [...((_a = settings.properties) !== null && _a !== void 0 ? _a : []), ...((_c = (_b = settings.environment) === null || _b === void 0 ? void 0 : _b.properties) !== null && _c !== void 0 ? _c : [])],
        batchInfo: settings.batch && {
            id: settings.batch.id,
            name: settings.batch.name,
            batchSequenceName: settings.batch.sequenceName,
            startedAt: settings.batch.startedAt,
            notifyOnCompletion: settings.batch.notifyOnCompletion,
            properties: settings.batch.properties,
            buildId: settings.batch.buildId,
        },
        egSessionId: (_e = (_d = settings.environment) === null || _d === void 0 ? void 0 : _d.ecSessionId) !== null && _e !== void 0 ? _e : null,
        environment: settings.environment &&
            (settings.environment.rawEnvironment
                ? {
                    ...settings.environment.rawEnvironment,
                    os: (_f = settings.environment.os) !== null && _f !== void 0 ? _f : settings.environment.rawEnvironment.os,
                    osInfo: (_g = settings.environment.displayOs) !== null && _g !== void 0 ? _g : settings.environment.rawEnvironment.osInfo,
                    hostingApp: (_h = settings.environment.hostingApp) !== null && _h !== void 0 ? _h : settings.environment.rawEnvironment.hostingApp,
                    hostingAppInfo: (_j = settings.environment.displayHostingApp) !== null && _j !== void 0 ? _j : settings.environment.rawEnvironment.hostingAppInfo,
                }
                : {
                    deviceInfo: settings.environment.deviceName,
                    os: settings.environment.os,
                    osInfo: settings.environment.displayOs,
                    hostingApp: settings.environment.hostingApp,
                    hostingAppInfo: settings.environment.displayHostingApp,
                    displaySize: settings.environment.viewportSize
                        ? utils.geometry.round(settings.environment.viewportSize)
                        : { width: 0, height: 0 },
                    inferred: settings.environment.userAgent && `useragent:${settings.environment.userAgent}`,
                }),
        environmentName: settings.environmentName,
        baselineEnvName: settings.baselineEnvName,
        branchName: settings.branchName,
        parentBranchName: settings.parentBranchName,
        baselineBranchName: settings.baselineBranchName,
        compareWithParentBranch: settings.compareWithParentBranch,
        parentBranchBaselineSavedBefore: settings.gitBranchingTimestamp,
        ignoreBaseline: settings.ignoreBaseline,
        saveDiffs: settings.saveDiffs,
        timeout: settings.abortIdleTestTimeout,
        isComponentAgent: settings.isComponentTest,
        fallbackExpectedOutput: settings.fallbackBaselineId,
        latestCommitInfo: settings.latestCommitInfo,
        processId: settings.processId,
        replaceExisting: settings.removeDuplicateTests,
    };
}
function toServerMatchOptions({ target, settings }) {
    var _a, _b;
    const serverRegions = (0, server_region_converter_1.serverRegionConverter)(settings);
    return {
        appOutput: {
            title: target.name,
            screenshotUrl: target.image,
            domUrl: target.dom,
            domMappingUrl: settings.domMapping,
            location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
            pageCoverageInfo: settings.pageId && {
                pageId: settings.pageId,
                imagePositionInPage: target.locationInView && utils.geometry.round(target.locationInView),
                ...(target.fullViewSize && utils.geometry.round(target.fullViewSize)),
            },
        },
        options: {
            imageMatchSettings: {
                ignore: serverRegions.ignore,
                layout: serverRegions.layout,
                strict: serverRegions.strict,
                content: serverRegions.content,
                floating: serverRegions.floating,
                accessibility: serverRegions.accessibility,
                dynamic: serverRegions.dynamic,
                accessibilitySettings: settings.accessibilitySettings,
                ignoreDisplacements: settings.ignoreDisplacements,
                ignoreCaret: settings.ignoreCaret,
                enablePatterns: settings.enablePatterns,
                matchLevel: (_a = settings.matchLevel) !== null && _a !== void 0 ? _a : 'Strict',
                useDom: (_b = settings.useDom) !== null && _b !== void 0 ? _b : false,
                densityMetrics: settings.densityMetrics,
            },
            name: settings.name,
            source: target.source,
            renderId: settings.renderId,
            variantId: settings.userCommandId,
            ignoreMismatch: settings.ignoreMismatch,
            ignoreMatch: settings.ignoreMatch,
            forceMismatch: settings.forceMismatch,
            forceMatch: settings.forceMatch,
            replaceLast: settings.replaceLast,
        },
    };
}
