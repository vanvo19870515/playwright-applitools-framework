"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = exports.expect = void 0;
/* eslint-disable no-console */
const index_1 = require("../index");
const test_1 = require("@playwright/test");
const getEyes_1 = require("./getEyes");
var toHaveScreenshot_1 = require("./toHaveScreenshot");
Object.defineProperty(exports, "expect", { enumerable: true, get: function () { return toHaveScreenshot_1.expect; } });
const reporter_1 = require("./reporter");
const url_1 = require("url");
const utils_1 = require("@applitools/utils");
exports.test = test_1.test.extend({
    eyesConfig: [{}, { option: true }],
    eyesRunner: [
        async ({}, use, workerInfo) => {
            var _a;
            const eyesConfig = await getEyesConfigForWorker(workerInfo);
            const runner = eyesConfig.type === 'ufg' ? new index_1.VisualGridRunner(eyesConfig) : new index_1.ClassicRunner(eyesConfig);
            await use(runner);
            if (runner.isUsed) {
                output(`Waiting on eyes results for worker #${workerInfo.parallelIndex}-${workerInfo.workerIndex} - it might take a while`);
            }
            try {
                await Promise.all((_a = runner === null || runner === void 0 ? void 0 : runner.fixturePromises) !== null && _a !== void 0 ? _a : []);
                await runner.getAllTestResults(eyesConfig.failTestsOnDiff === 'afterAll').catch(err => {
                    const newError = new Error(err.message);
                    newError.stack = undefined;
                    throw newError;
                });
            }
            finally {
                const results = await runner.getAllTestResults(false);
                if (runner.isUsed) {
                    output(outputDigest(workerInfo, results));
                }
                if (eyesConfig.afterAll) {
                    await eyesConfig.afterAll(results.getAllResults());
                }
            }
        },
        { scope: 'worker', timeout: 0 },
    ],
    page: async ({ page, eyesRunner, eyesConfig }, use) => {
        // save the configurations and settings for the `expect.toHaveScreenshot` override
        ;
        page.__eyesRunner = eyesRunner;
        page.__eyesConfig = eyesConfig; // TODO merge playwrightConfig, projectConfig, eyesConfig
        await use(page);
    },
    eyes: [
        async ({ page, eyesConfig, eyesRunner }, use, testInfo) => {
            const eyes = await (0, getEyes_1.getEyes)({
                testInfo,
                eyesConfig,
                eyesRunner,
                page,
            });
            await use(eyes);
        },
        { timeout: 0 },
    ],
    closeEyesIfNeeded: [
        async ({ page, eyesConfig, eyesRunner: runner }, use, testInfo) => {
            const isUsingEyesReporter = testInfo.config.reporter.some(
            // typeof testInfo.config.reporter is [string, ReporterOptions][], that's why [0] is the reporter name
            r => r[0].includes('eyes-playwright') || r[0].includes('blob'));
            await use();
            const eyes = page.__eyes;
            if (eyes) {
                await eyes.closeAsync();
                if (isUsingEyesReporter) {
                    await writeResultsWhenReady({ eyes, runner, testInfo });
                }
                if (eyesConfig.failTestsOnDiff === 'afterEach') {
                    await eyes.getResults(true);
                }
            }
        },
        { timeout: 0, auto: true },
    ],
});
function outputDigest(workerInfo, results) {
    const batchUrls = [...new Set(results.getAllResults().map(r => r.testResults.appUrls.batch))];
    if (batchUrls.length === 0) {
        return 'No results found for Eyes';
    }
    else {
        return `Eyes results for worker #${workerInfo.parallelIndex}-${workerInfo.workerIndex}: ${batchUrls.length > 1 ? batchUrls.join('\n  ') : batchUrls[0]}`;
    }
}
function output(...args) {
    console.log('ðŸ‘€', ...args);
}
async function writeResultsWhenReady({ eyes, runner, testInfo }) {
    var _a, _b;
    const fixturePromises = ((_a = runner.fixturePromises) !== null && _a !== void 0 ? _a : (runner.fixturePromises = []));
    const uuid = utils_1.general.guid();
    await testInfo.attach('applitoolsIdentifier', {
        body: `${uuid}|${(_b = eyes.getServerUrl()) !== null && _b !== void 0 ? _b : 'https://eyes.applitools.com'}|${eyes.getApiKey()}`,
    });
    fixturePromises.push(eyes
        .getResults(false)
        .then(async (testResults) => {
        await reporter_1.InternalData.write({ testInfo, data: testResults, eyes, uuid });
    })
        .catch((e) => {
        var _a;
        // TODO error handling
        throw new Error(`Failed to get eyes test results: ${(_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : e} ${e === null || e === void 0 ? void 0 : e.stack}`);
    }));
}
async function getEyesConfigForWorker(workerInfo) {
    var _a, _b, _c, _d;
    const { configFile } = workerInfo.config;
    const playwrightConfigModule = configFile ? await import((0, url_1.pathToFileURL)(configFile).href) : {};
    const playwrightConfig = ((_a = playwrightConfigModule === null || playwrightConfigModule === void 0 ? void 0 : playwrightConfigModule.use) === null || _a === void 0 ? void 0 : _a.eyesConfig) ||
        ((_c = (_b = playwrightConfigModule === null || playwrightConfigModule === void 0 ? void 0 : playwrightConfigModule.default) === null || _b === void 0 ? void 0 : _b.use) === null || _c === void 0 ? void 0 : _c.eyesConfig);
    const projectConfig = workerInfo.project.use.eyesConfig;
    const eyesConfig = {
        ...playwrightConfig,
        ...projectConfig,
    };
    (_d = eyesConfig.failTestsOnDiff) !== null && _d !== void 0 ? _d : (eyesConfig.failTestsOnDiff = process.env.CI ? 'afterAll' : 'afterEach');
    return eyesConfig;
}
