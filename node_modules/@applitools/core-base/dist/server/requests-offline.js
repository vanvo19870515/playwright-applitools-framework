"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeCoreRequestsOfflineWithCache = void 0;
const logger_1 = require("@applitools/logger");
const utils = __importStar(require("@applitools/utils"));
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
exports.makeCoreRequestsOfflineWithCache = utils.general.cachify(makeCoreRequestsOffline, ([{ folderPath }]) => folderPath);
function makeCoreRequestsOffline({ folderPath, logger: defaultLogger, }) {
    const startedAt = new Date();
    const mainLogger = (0, logger_1.makeLogger)({ logger: defaultLogger, format: { label: 'core-requests-offline' } });
    mainLogger.log('offline requests initialized at path', folderPath);
    const core = {
        concurrency: undefined,
        getAccountInfo,
        updateIfScm,
        openEyes,
        openFunctionalSession,
        locate,
        locateText,
        extractText,
        closeBatch,
        deleteTest,
        logEvent,
        sendHeartbeat,
        openCheckAndClose,
        openCheckAndCloseEyes,
    };
    return core;
    async function getAccountInfo() {
        // static implementation, should return rcaEnabled, large limits for screenshots, etc.
        return {
            eyesServer: {
                eyesServerUrl: 'offline eyesServerUrl',
                apiKey: 'offline apiKey',
                // agentId?: string
                // proxy?: Proxy
                // useDnsCache?: boolean
            },
            ufgServer: {
                ufgServerUrl: 'offline ufgServerUrl',
                accessToken: 'offline accessToken',
                // agentId?: string
                // proxy?: Proxy
                // useDnsCache?: boolean
            },
            supportedEnvironmentsUrl: 'offline supportedEnvironmentsUrl',
            stitchingServiceUrl: 'offline stitchingServiceUrl',
            uploadUrl: 'offline uploadUrl',
            maxImageHeight: 1000000,
            maxImageArea: 1000000000,
            rcaEnabled: true,
            selfHealingEnabled: true,
            ecEnabled: true,
            processKeepaliveIntervalSec: 0,
            batchPropertiesLimits: { maxNameLength: 9999, maxValueLength: 9999, maxTotalLength: 5000 }, // maxTotalLength used in warning
        };
    }
    async function updateIfScm() {
        return null; // no auto populate scm info in offline mode
    }
    async function openEyes({ settings, heartbeat: _heartbeat, logger = mainLogger, }) {
        var _a, _b, _c;
        logger = logger.extend(mainLogger, { tags: [`core-request-offline-${utils.general.shortid()}`] });
        logger.log('Offline request "openEyes" called with settings', settings);
        let resultResponsePromise;
        const settingsToSave = { ...settings };
        delete settingsToSave.processId;
        delete settingsToSave.userTestId;
        (_a = settingsToSave.environment) === null || _a === void 0 ? true : delete _a.environmentId;
        const testFolderPath = await createTestFolder(folderPath, settingsToSave);
        logger.log('testFolderPath', testFolderPath);
        await fs_1.default.promises.writeFile(path_1.default.resolve(testFolderPath, 'settings.json'), JSON.stringify(settingsToSave, null, 2));
        const account = await getAccountInfo();
        const initializedAt = 'dummy initialized at';
        const result = {
            id: 'id',
            batchId: 'batch id',
            baselineId: 'baseline id',
            sessionId: 'session id',
            isNew: false,
            url: 'results url',
        };
        const test = {
            testId: result.id,
            // TODO revisit the need for it
            testName: settings.testName,
            userTestId: settings.userTestId,
            batchId: (_c = (_b = settings.batch) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : result.batchId,
            baselineId: result.baselineId,
            sessionId: result.sessionId,
            initializedAt,
            appId: settings.appName,
            isNew: result.isNew,
            keepBatchOpen: !!settings.keepBatchOpen,
            keepIfDuplicate: !!settings.baselineEnvName,
            resultsUrl: result.url,
            eyesServer: account.eyesServer,
            ufgServer: account.ufgServer,
            uploadUrl: account.uploadUrl,
            supportedEnvironmentsUrl: account.supportedEnvironmentsUrl,
            stitchingServiceUrl: account.stitchingServiceUrl,
            account,
            environment: settings.environment,
        };
        return {
            get running() {
                return !resultResponsePromise;
            },
            test,
            core,
            check,
            checkAndClose,
            close,
            abort,
            getResults,
            report,
        };
        async function check({ target: _target, settings, logger = mainLogger, }) {
            logger = logger.extend(mainLogger, { tags: [`core-request-offline-${utils.general.shortid()}`] });
            logger.log('Offline request "check" called with settings', settings);
            const checkFolderPath = createCheckFolder(testFolderPath, settings);
            logger.log('checkFolderPath', checkFolderPath);
            const renderPath = settings.renderId;
            // const snapshot = await fs.promises.readFile(renderPath, 'utf-8').then(JSON.parse)
            // const source = new URL(snapshot.target.source).origin
            // for (const [resourceUrl, resource] of Object.entries(snapshot.target.resources)) {
            //   if (resource.contentType.includes('text/css')) {
            //     // TODO read resource file and replace source with 'http://offline'
            //     path.resolve(renderPath, '../../resources', resource.hash)
            //   }
            //   // TODO read snapshot.target.snapshot.hash, read the file, replace source
            // }
            const newPath = path_1.default.resolve(checkFolderPath, 'snapshot.json');
            await fs_1.default.promises.rename(renderPath, newPath);
            logger.log('render target file moved from', renderPath, 'to', newPath);
            return { asExpected: true };
        }
        async function checkAndClose({ target: _target, settings, logger = mainLogger, }) {
            logger = logger.extend(mainLogger, { tags: [`core-request-offline-${utils.general.shortid()}`] });
            logger.log('Offline request "checkAndClose" called with settings', settings);
            // check
            const checkFolderPath = createCheckFolder(testFolderPath, settings);
            logger.log('checkFolderPath', checkFolderPath);
            const renderPath = settings.renderId;
            const newPath = path_1.default.resolve(checkFolderPath, 'snapshot.json');
            await fs_1.default.promises.rename(renderPath, newPath);
            logger.log('render target file moved from', renderPath, 'to', newPath);
            // close
            resultResponsePromise = fs_1.default.promises
                .writeFile(path_1.default.resolve(testFolderPath, 'close.json'), JSON.stringify(settings, null, 2))
                .then(Boolean);
            return resultResponsePromise
                .then(() => {
                logger.log('Request "close" finished successfully');
            })
                .catch(() => undefined);
        }
        async function close({ settings, logger = mainLogger }) {
            logger = logger.extend(mainLogger, { tags: [`core-request-offline-${utils.general.shortid()}`] });
            logger.log('Offline request "close" called with settings', settings);
            resultResponsePromise = fs_1.default.promises
                .writeFile(path_1.default.resolve(testFolderPath, 'close.json'), JSON.stringify(settings, null, 2))
                .then(Boolean);
            return resultResponsePromise
                .then(() => {
                logger.log('Request "close" finished successfully');
            })
                .catch(() => undefined);
        }
        async function abort({ settings, logger = mainLogger }) {
            logger = logger.extend(mainLogger, { tags: [`core-request-offline-${utils.general.shortid()}`] });
            logger.log('Offline request "abort" called with settings', settings);
            // TODO implement offline aborted test
            // await fs.promises.writeFile(path.resolve(testFolderPath, 'close.json'), JSON.stringify(settings, null, 2))
            // resultResponsePromise = createTarArchive({sourcePath: testFolderPath, logger}).then(Boolean)
            // return resultResponsePromise
            //   .then(() => {
            //     logger.log('Request "close" finished successfully')
            //   })
            //   .catch(() => undefined)
        }
        async function getResults({ settings, logger = mainLogger, }) {
            logger = logger.extend(mainLogger, { tags: [`core-request-offline-${utils.general.shortid()}`] });
            logger.log('Offline request "getResults" called with settings', settings);
            if (resultResponsePromise === undefined) {
                logger.warn(`The test with userTestId "${test.userTestId}" is going to be auto aborted`);
                await abort({ settings, logger });
            }
            await resultResponsePromise;
            return [
                {
                    status: 'Passed',
                    id: 'id',
                    baselineId: result.baselineId,
                    userTestId: test.userTestId,
                    batchId: result.batchId,
                },
            ];
        }
        async function report() {
            // empty
        }
        function createTestFolder(basePath, settings) {
            const testFolderPath = path_1.default.resolve(basePath, getNameForFolder(settings));
            if (fs_1.default.existsSync(testFolderPath)) {
                logger.log(`removing already existing folder: ${testFolderPath}`);
                fs_1.default.rmdirSync(testFolderPath);
            }
            fs_1.default.mkdirSync(testFolderPath, { recursive: true });
            return testFolderPath;
        }
        function getNameForFolder(settings) {
            const nameBeforeHash = JSON.stringify({
                testName: settings.testName,
                environment: settings.environment,
                appName: settings.appName,
            });
            const nameAfterHash = crypto_1.default.createHash('md5').update(nameBeforeHash).digest('hex');
            logger.log(`name for folder before hash: ${nameBeforeHash} and after hash: ${nameAfterHash}`);
            return `test-${nameAfterHash}`;
        }
        function createCheckFolder(testFolderPath, settings) {
            const checkFolderPath = path_1.default.resolve(testFolderPath, `check-${settings.stepIndex ? settings.stepIndex + 1 : 0}`);
            fs_1.default.mkdirSync(checkFolderPath, { recursive: true });
            return checkFolderPath;
        }
    }
    async function openFunctionalSession() {
        throw new Error('not implemented');
    }
    async function locate() {
        throw new Error('not implemented');
    }
    async function locateText() {
        throw new Error('not implemented');
    }
    async function extractText() {
        throw new Error('not implemented');
    }
    async function closeBatch({ logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-offline-${utils.general.shortid()}`] });
        logger.log('Offline request "closeBatch" called');
        logger.console.log(`Eyes is done for execution that started at ${startedAt}. Run the following to create visual tests:\n\n    npx eyes run-offline-snapshots --offlineLocationPath=${folderPath}\n`);
    }
    async function deleteTest() {
        // empty
    }
    async function logEvent() {
        // empty
    }
    async function sendHeartbeat() {
        // empty
    }
    async function openCheckAndClose() {
        throw new Error('not implemented');
    }
    function openCheckAndCloseEyes() {
        throw new Error('not implemented');
    }
}
